<HTML><HEAD><TITLE>Расширение набора стандартных функций и классов Borland Delphi</TITLE><META http-equiv="Content-Type" content="text/html; charset=windows-1251">
<STYLE>
BODY
  { font-family:verdana,tahoma; font-size:x-small; color:#000000; background-color:#FFFFFF; text-align:justify; padding-left:15; padding-right:15 }
P, UL, OL, DL
  { font-family:verdana,tahoma; font-size:x-small; text-align:justify }
H1
  { font-family: arial; font-size:large; font-weight:bolder; text-align:center; color:#4580A0 }
H1 DIV.subtitle
  { font-family: verdana,tahoma; font-size:small; font-weight:lighter; margin-top=12px }
H2
  { font-family: verdana,tahoma; font-size:large; font-weight:lighter; font-variant:small-caps; text-align:left; color:#4580A0 }
H4
  { font-family: tahoma,verdana; font-size:x-small; margin-left:0.1em; font-weight:bold; text-align:left; color:#4580A0 }
H6
  { font-family: arial; font-size:x-small; font-style:italic; text-align:right; font-weight:lighter; color:#0 }
P I   
  { font-family: arial }
A 
  { text-decoration:none; font-family: tahoma; color:#6677AA } 
A:hover 
  { text-decoration:underline; color:#8899CC }
</STYLE>
</HEAD>
<P>
<A href="http://acedutils.narod.ru/index.htm">Перейти на главную страницу</A>&nbsp;&nbsp;
<A href="http://acedutils.narod.ru/AcedUtils.zip">Загрузить файл AcedUtils.zip</A>
</P>
<H1>Расширение набора стандартных функций и классов Borland Delphi<DIV class="subtitle">Описание библиотеки AcedUtils для Borland Delphi на платформе Win32</DIV></H1>
<A href="#IDA4IGGD"><B>Предисловие</B></A><BR><DIV style="margin-left:2em">
</DIV><A href="#IDAOLGGD"><B>Модуль AcedMemory</B></A><BR><DIV style="margin-left:2em">
</DIV><A href="#IDA0LGGD"><B>Модуль AcedBinary</B></A><BR><DIV style="margin-left:2em">
</DIV><A href="#IDAKMGGD"><B>Модуль AcedStreams</B></A><BR><DIV style="margin-left:2em">
</DIV><A href="#IDAUMGGD"><B>Модуль AcedStrings</B></A><BR><DIV style="margin-left:2em">
</DIV><A href="#IDAMNGGD"><B>Модуль AcedCommon</B></A><BR><DIV style="margin-left:2em">
</DIV><A href="#IDACPGGD"><B>Модуль AcedCompression</B></A><BR><DIV style="margin-left:2em">
</DIV><A href="#IDAFYGGD"><B>Модуль AcedCrypto</B></A><BR><DIV style="margin-left:2em">
</DIV><A href="#IDATYGGD"><B>Модуль AcedAlgorithm</B></A><BR><DIV style="margin-left:2em">
</DIV><A href="#IDAFZGGD"><B>Модуль AcedContainers</B></A><BR><DIV style="margin-left:2em">
</DIV><A href="#IDAT1GGD"><B>Модуль AcedStorage</B></A><BR><DIV style="margin-left:2em">
</DIV><A href="#IDAN3GGD"><B>Модуль AcedExcelReport</B></A><BR><DIV style="margin-left:2em">
</DIV><A href="#IDAT4GGD"><B>Описание демонстрационного проекта</B></A><BR><DIV style="margin-left:2em">
</DIV><A href="#IDAL5GGD"><B>Заключение</B></A><BR><DIV style="margin-left:2em">
</DIV>
</DIV>
<H2><A name="IDA0IGGD"></A></H2>
<P>В статье описывается библиотека функций и классов AcedUtils, которая содержит реализацию распространенных структур данных и алгоритмов на языке Delphi для платформы Win32. Код библиотеки написан и протестирован на Borland Delphi 7.</P>
<H2>Предисловие<A name="IDA4IGGD"></A></H2>
<P>При разработке функций и классов, составляющих библиотеку, основное внимание уделялось оптимизации кода по быстродействию. Но секрет достижения максимальной производительности заключается не столько в оптимизации машинного кода, ассемблерных вставках и т.п., сколько в использовании подходящих алгоритмов. Например, если стоит задача поиска некоторого значения в массиве элементов, можно пойти несколькими путями. Самый простой путь – последовательный перебор элементов и сравнение их с искомым значением. Для массива, содержащего всего несколько элементов, этот метод может оказаться самым эффективным. Если массив содержит много элементов, лучше заранее отсортировать его, а затем использовать бинарный поиск, который несравнимо быстрее последовательного перебора элементов. Если число элементов массива измеряется десятками тысяч и поиск в нем выполняется часто, имеет смысл пожертвовать лишней памятью для организации хэшированного списка. Время поиска в хэше не зависит от размера массива. Но и хэшированный список имеет свои недостатки, как, например, невозможность последовательной индексации элементов. Функции и классы из AcedUtils представляют собой готовый инструментарий, включающий распространенные алгоритмы работы с данными. Разработчик может опробовать различные варианты и выбрать из них тот, который лучше подходит для конкретной задачи.</P>
<P>В последних версиях библиотеки добавлены классы для работы со сбалансированными бинарными деревьями (красно-черными деревьями), двухсторонними очередями (деками), приоритетными очередями. Добавлены функции, реализующие эффективные алгоритмы сортировки и поиска элементов набора данных (интроспективную сортировку, частичную сортировку, сортировку с сохранением относительного порядка следования равных элементов), различные перестановочные алгоритмы, функции для слияния упорядоченных наборов элементов, а также для работы с кучей.</P>
<P>Кратко рассмотрим назначение модулей в составе AcedUtils.</P>
<UL style="LIST-STYLE:square"><LI><STRONG>AcedMemory</STRONG> – реализует менеджер памяти, оптимизированный для работы с большим числом мелких и средних фрагментов данных. Особенностью является ведение пула блоков памяти одного размера. Таким образом решается проблема дефрагментации пространства памяти, занятого блоками размером до 48кБ. Кроме того, данный менеджер памяти отличается высоким быстродействием и оптимальным, с точки зрения кэширования памяти, выравниванием распределяемых блоков.</LI>
<LI><STRONG>AcedConsts</STRONG> – содержит константы и методы, используемые другими модулями в составе AcedUtils. Кроме того, содержит определение типов ссылок на массивы, таких как PIntegerItemList, PObjectItemList, PPointerItemList и других.</LI>
<LI><STRONG>AcedBinary</STRONG> – объединяет функции для работы с блоками памяти, массивами байт, чисел типа Integer, Word, LongWord, битами в составе двойного слова и битовыми строками. Включает также функции для эффективной работы с упорядоченными массивами одинарных и двойных слов, выполнения логических операций над множествами, представленными в виде таких массивов.</LI>
<LI><STRONG>AcedStreams</STRONG> – содержит классы TBinaryReader и TBinaryWriter, позволяющие считывать данные из бинарного потока и помещать данные в бинарный поток. Исходные и выходные данные бинарного потока могут представляться в виде массива байт, строки в кодировке Base64, файла на диске или потока типа TStream. Данные, помещенные в бинарный поток, защищаются контрольной суммой Адлера и, при необходимости, сжимаются методом LZ+Huffman. Кроме того, данные в потоке могут быть зашифрованы методом RC6 и защищены цифровой сигнатурой SHA-256. В модуле AcedStreams также находятся классы TReaderStream и TWriterStream, которые позволяют работать с экземплярами классов TBinaryReader и TBinaryWriter, как будто эти классы являются потомками стандартного класса TStream.</LI>
<LI><STRONG>AcedStrings</STRONG> – содержит разнообразные функции для работы со строками, в частности, для сравнения строк с учетом и без учета регистра символов, перевода символов и строк в верхний/нижний регистр, перекодировки строк из DOS в Windows и обратно, поиска, замены, удаления подстрок и т.д. Кроме того, в AcedStrings находится класс TStringBuilder, предназначенный для построения длинных строк из отдельных фрагментов, а также изменения таких строк "на месте". При использовании этого класса память не распределяется заново каждый раз при добавлении к строке следующего фрагмента. Построение длинной строки с помощью экземпляра класса TStringBuilder выполняется значительно быстрее простой конкатенации строк в цикле.</LI>
<LI><STRONG>AcedCommon</STRONG> – объединяет разнообразные функции, не выделенные в отдельные категории, в частности, функции форматирования даты и времени, расчета контрольной суммы Адлера и CRC-32, перевода строки или байтового массива в кодировку Base64 и восстановления из кодировки Base64, преобразования числа в строку и обратно, функции для записи денежной суммы прописью, для работы со счетчиками и таймерами при измерении временных интервалов. Кроме того, здесь находятся некоторые вспомогательные функции, в том числе относящиеся к пользовательскому интерфейсу.</LI>
<LI><STRONG>AcedCompression </STRONG>– содержит функции, реализующие сжатие бинарных данных методом LZ+Huffman, и последующую распаковку данных, сжатых таким способом. Используемый алгоритм упаковки представляет собой немного измененный вариант алгоритма, который реализуется архиватором PKZIP. За счет этих изменений достигается большая степень сжатия.</LI>
<LI><STRONG>AcedCrypto </STRONG>– объединяет функции для шифрования данных методами RC4 и RC6 (в режимах ECB, CFB и OFB), для расчета значения односторонней хэш-функции SHA-256, используемой при верификации данных. Цифровая сигнатура SHA-256 может вычисляться как для целой строки или массива байт, так и для данных, представленных в виде нескольких фрагментов. В этом же модуле находятся функции, реализующие генератор псевдослучайных чисел Mersenne Twister с периодом 2<SUP>19937</SUP>-1.</LI>
<LI><STRONG>AcedAlgorithm </STRONG>– различные функции для манипулирования набором данных, представленным в виде массива указателей. Включает функции для линейного и бинарного поиска, замены, подсчета, удаления элементов массива, поиска максимального и/или минимального элементов, а также реализацию некоторых перестановочных алгоритмов. Имеется группа функций для сортировки элементов массива, а также для слияния сортированных массивов с применением различных операций над множествами. Кроме того, есть группа функций для работы с кучей (в данном контексте под кучей подразумевается бинарное дерево в виде последовательной коллекции, обладающее специальными свойствами).</LI>
<LI><STRONG>AcedContainers</STRONG> (бывший AcedLists) – содержит классы, являющиеся контейнерами данных, в том числе, для работы с битовыми строками (TBitList), наборами чисел типа Integer (TIntegerList) и Word (TWordList), обычными (TArrayList, TArrayReadOnlyList), ассоциативными (TIntegerAssociationList, TStringAssociationList), хэшированными (TIntegerHashtable, TStringHashtable), связанными (TLinkedList) списками, самобалансируемыми красно-черными бинарными деревьями (TIntegerRedBlackTree, TInt64RedBlackTree, TStringRedBlackTree), двухсторонними (TDoubleEndedQueue) и приоритетными (TPriorityQueue) очередями.</LI>
<LI><STRONG>AcedStorage</STRONG> – объединяет классы для организации объектного хранилища данных, которое представляет собой эффективный способ хранения данных на локальном компьютере или файловом сервере с возможностью многопользовательского доступа. При реализации объектного хранилища используется хэширование записей по первичным ключам, индексация с возможностью выделения диапазонов значений, уведомления об изменении данных, поддерживаются ограничения уникальности. Для обеспечения возможности одновременного изменения данных одного набора, т.е. коллекции, несколькими пользователями применяется механизм транзакций. Каждая таблица данных представляется коллекцией типа TSerializableCollection, в которой содержатся записи – объекты, производные от класса TSerializableObject.</LI>
<LI><STRONG>AcedNetWait</STRONG> – форма, которая используется модулем AcedStorage при возникновении коллизий на файловом сервере. На экран выводится сообщение о том, что в данный момент открываемый файл данных заблокирован, т.к. он записывается другим пользователем или другим приложением. В этом случае пользователь должен подождать, повторить попытку открытия файла или отменить операцию. Следует отметить, что файл данных блокируется только на время автоматического согласования изменений и непосредственного сохранения данных. Блокировка не выполняется в процессе интерактивной корректировки данных одной и той же таблицы несколькими пользователями.</LI>
<LI><STRONG>AcedExcelReport</STRONG> – содержит функции и классы, облегчающие подготовку и печать отчетов с помощью Microsoft Excel. Обычно при работе с Microsoft Excel из Delphi приходится обращаться к различным интерфейсам из модуля Excel97, сгенерированного на основе библиотеки типов Microsoft Excel. В модуле AcedExcelReport собраны функции, наиболее часто используемые при подготовке отчетов. Это позволяет сократить размер и уменьшить сложность кода для генерации отчетов, а также сократить число обращений к Microsoft Excel через COM-интерфейсы, что существенно повышает производительность.</LI>
<LI><STRONG>AcedGridFrame</STRONG>, <STRONG>AcedCheckFrame</STRONG>, <STRONG>AcedViewFrame</STRONG> – фреймы для отображения на экране данных в виде таблицы с возможностью навигации. Представляют собой аналог компонента TStringGrid с расширенными возможностями. AcedGridFrame отображает таблицу и строку поиска. Для столбцов задается режим выравнивания и заголовок. Каждая ячейка может отображаться своим цветом. Поддерживается многострочный текст в ячейках и режим отложенного выделения записей. AcedCheckFrame, кроме того, показывает окно пометки (Checkbox) рядом с каждой записью и предоставляет коллекцию помеченных записей и коллекцию недоступных записей, для которых нельзя изменить пометку. AcedViewFrame отображает информацию в виде таблицы без строки поиска и выделения цветом текущей записи. Этот фрейм игнорирует события от клавиатуры, но предоставляет методы для скроллинга таблицы из кода. Дополнительную информацию о grid-фреймах можно почерпнуть из комментариев в исходном коде соответствующих модулей.</LI>
<LI><STRONG>AcedGrids</STRONG> – содержит описание общих типов и событий, используемых фреймами: AcedGridFrame, AcedCheckFrame и AcedViewFrame.</LI>
</UL>
<P>Теперь подробнее рассмотрим функциональность основных модулей AcedUtils. </P>
<H2>Модуль AcedMemory<A name="IDAOLGGD"></A></H2>
<P>Этот модуль предназначен для замены стандартного менеджера памяти Borland Delphi альтернативным механизмом распределения памяти. Целью разработки нового менеджера памяти было стремление оптимизировать работу с небольшими блоками памяти, которые возникают при организации хранения данных в виде объектной базы, когда каждая запись базы данных представляется в памяти экземпляром соответствующего класса. Под оптимизацией подразумевается, во-первых, повышение скорости при выделении/освобождении блоков памяти, во-вторых, решение проблемы фрагментации свободных блоков. Рассмотрим подробнее принцип работы AcedMemory.</P>
<P>Память запрашивается у операционной системы вызовом VirtualAlloc блоками размером 3МБ, которые в данном контексте называются регионами. Каждый регион состоит из 32 блоков размером 96кБ. Каждый такой блок предназначен для фрагментов памяти определенного размера. Например, один блок может содержать 6 фрагментов по 16кБ, другой – 1536 фрагментов по 64 байта и т.д. Когда из прикладной программы вызывается функция GetMem, размер выделяемого фрагмента памяти в байтах округляется вверх до ближайшего числа из следующего списка: 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576, 32768, 49152. Когда все фрагменты памяти нужного размера в составе блока заняты, в регионе выделяется следующий блок под фрагменты памяти нужного размера. Если все 32 блока в составе региона заняты, создается новый регион размером 3МБ. Адрес каждого фрагмента памяти (до 48кБ) кратен его размеру, что положительно влияет на производительность. Когда требуется выделить фрагмент памяти размером более 48кБ, этот размер дополняется 8 байтами для хранения служебной информации и округляется вверх до числа, кратного 4096 байт. Затем вызывается функция VirtualAlloc для запроса соответствующего блока памяти у операционной системы.</P>
<P>Для подключения AcedMemory к проекту, ссылку на этот модуль необходимо добавить в раздел uses файла проекта, причем AcedMemory должен стоять первым в этом разделе. Стандартные модули Forms, Classes и прочие должны находиться в списке uses, после AcedMemory. Если этого не сделать, при завершении программы возникнет ошибка. Это происходит из-за того, что в разделе finalization модуля Classes косвенно вызывается функция FreeMem для освобождения некоторых блоков памяти, выделенных в процессе работы программы. Модули финализируются в порядке, обратном их перечислению в разделе uses файла проекта. Чтобы менеджер памяти AcedMemory был еще активен на момент вызова раздела finalization модуля Classes, ссылка на AcedMemory должна находиться в списке uses файла проекта перед модулем Classes и любыми другими модулями, использующими Classes, такими, как модуль Forms.</P>
<P>Кроме, собственно, механизма для выделения/освобождения памяти, в модуле AcedMemory имеется несколько вспомогательных функций: G_GetMemSize возвращает размер блока памяти, адрес которого передан как параметр; функция G_GetTotalMemAllocated возвращает общий объем памяти, выделенный прикладной программе. Вызов этой функции не приводит к длительному пересчету размеров всех выделенных блоков. Вместо этого просто возвращается значение внутреннего счетчика памяти. Функция G_GetTotalMemCommitted возвращает общий размер физической памяти, выделенной программе операционной системой. Это число не учитывает память, выделенную в "куче" для служебных структур модуля AcedMemory, а также память, распределенную средствами, отличными от менеджера памяти.</P>
<H2>Модуль AcedBinary<A name="IDA0LGGD"></A></H2>
<P>В этом модуле собрано большое число функций для работы с бинарными данными, представленными массивами байт, слов, двойных слов, битовыми строками, отдельными значениями типа LongWord. Подробное их описание можно найти в исходном коде модуля. В некоторых функциях используются инструкции MMX, для выполнения которых нужен процессор, начиная с Pentium-MMX (вместе с исходным кодом есть вариант модулей AcedBinary и AcedCrypto без использования MMX). Кратко рассмотрим основные группы функций.</P>
<P>Первая группа объединяет функции для обмена значений переменных и несколько функций для работы с числами типа LongWord. Она включает процедуры G_Swap32, G_Swap16, G_Swap8, обменивающие значения двух переменных соответствующего размера (в битах), процедуру G_BSwap, которая обращает порядок следования байт в значении типа LongWord, функции G_Log2, G_Gcd, G_Lcm, возвращающие, соответственно, логарифм числа по основанию 2, наибольший общий делитель двух чисел и наименьшее общее кратное двух чисел. Функции G_CeilPowerOfTwo, G_FloorPowerOfTwo округляют двойное слово до ближайшей степени числа 2 вверх или вниз, соответственно.</P>
<P>Ко второй группе относятся функции, работающие с массивами байт, слов и двойных слов. Например, когда необходимо заполнить нулями массив байт, пригодится процедура G_ZeroMem. Если нужно скопировать содержимое одного блока памяти в другой и заранее известно, что эти блоки памяти не перекрываются, вместо стандартной процедуры Move лучше воспользоваться процедурой G_CopyMem из AcedBinary, которая выполнит то же действие значительно быстрее. Если блоки памяти могут перекрываются, нужно использовать процедуру G_MoveMem. В этом случае при работе с массивами двойных слов можно немного повысить быстродействие, если вызывать, соответственно, процедуры G_CopyLongs и  G_MoveLongs. Кроме того, может быть полезна процедура G_FillLongs для заполнения массива двойных слов определенным значением или процедура G_GenerateLongs, заполняющая такой массив возрастающей или убывающей последовательностью целых чисел. Когда требуется найти число типа Word или Integer в несортированном массиве, вместо организации цикла с перебором элементов массива лучше вызвать функцию G_Scan_Word или G_Scan_Integer. Эти функции используют специальные машинные инструкции для быстрого поиска значения в массиве двух- или четырехбайтных элементов. Аналогичные функции имеются для поиска элемента с конца массива (G_ScanBackward…), поиска значения, отличающегося от заданного (G_ScanOther…), замены одних значений другими (G_Replace…) и т.д.</P>
<P>В AcedBinary есть группа функций для работы с отсортированными массивами элементов типа Integer, Word, LongWord, которая включает функции для, собственно, сортировки массива по возрастанию (G_Sort…), выполнения бинарного поиска (G_BinarySearch…). Сортированные массивы можно рассматривать как множества и применять к ним соответствующие операции. Например, массив уникальных элементов типа Integer – это одно из возможных представлений множества: [-2147483648..2147483647]. Функция G_SetUnion_Integer формирует из двух таких массивов новый массив, состоящий из элементов, которые присутствуют хотя бы в одном из исходных массивов; G_SetIntersection_Integer возвращает массив, состоящий только из тех элементов, которые присутствуют в обоих массивах; G_SetDifference_Integer возвращает массив элементов, которые присутствуют в первом, но отсутствуют во втором массиве; G_SetSymmetricDiffference_Integer формирует массив из элементов, которые присутствуют только в одном из исходных массивов. Есть еще две информационные функции для работы со множествами: G_SetIntersectsWith_Integer возвращает True, если в двух массивах есть какие-либо общие элементы, т.е. пересечение двух множеств не является пустым множеством; другая функция – G_SetContainedIn_Integer возвращает True, если все элементы первого массива присутствуют во втором массиве, т.е. первое множество является подмножеством второго. Аналогичные функции имеются для массивов элементов типа Word и LongWord. Эти функции могут использоваться совместно с классами TIntegerList и TWordList, определенными в модуле AcedContainers.</P>
<P>Следующая группа функций в AcedBinary предназначена для работы с битами в составе двойного слова, т.е. значения типа LongWord. Эта группа включает функцию G_ReverseBits (обращает порядок следования бит); G_BitTest32, G_BitSet32, G_BitReset32, G_BitToggle32 (используются для проверки, установки, сброса или инвертирования одного бита в составе двойного слова). Есть также функции для подсчета числа установленных и сброшенных бит, поиска первого или последнего бита с заданным состоянием и другие.</P>
<P>Последняя группа функций аналогична только что рассмотренной, но эти функции работают с битами в составе битовой строки. Например, функция G_BitSet устанавливает в единицу бит с заданным индексом в битовой строке, адресуемой первым параметром этой функции; функция G_ToggleBits инвертирует все биты в заданном диапазоне битовой строки; G_CountOfFreeBits возвращает число нулевых битов в заданном диапазоне битовой строке; G_SetBitScanForward возвращает индекс первого установленного, т.е. единичного, бита в составе битовой строки. Эти и другие функции используются классом TBitList из модуля AcedContainers для эффективной работы с данными, представленными в виде упакованного набора значений типа Boolean.</P>
<H2>Модуль AcedStreams<A name="IDAKMGGD"></A></H2>
<P>Модуль содержит классы, предназначенные для работы с бинарным потоком данных. Бинарный поток в данном контексте – это просто массив байт в памяти, размер которого динамически увеличивается по мере добавления новых данных. После того, как все данные помещены в поток, его содержимое может быть преобразовано в массив, строку в кодировке Base64, сохранено в файле или в другом потоке типа TStream. При этом может быть выполнено сжатие данных методом LZ+Huffman, шифрование методом RC6 и защита цифровой сигнатурой SHA-256. Для проверки целостности данных вместе с ними в поток помещается значение контрольной суммы Адлера. Бинарный поток создается с помощью экземпляра класса TBinaryWriter. Cтандартные классы в составе VCL ориентированы на работу с потоком типа TStream. Чтобы решить эту проблему в модуле AcedStreams предусмотрен класс TStreamWriter, который является потомком стандартного класса TStream и, одновременно, представляет собой оболочку над TBinaryWriter. Таким образом, можно, например, сохранить изображение типа TGraphic в потоке TBinaryWriter. Для этого нужно создать экземпляр TStreamWriter, передав в его конструктор ссылку на TBinaryWriter. Затем этот экземпляр TStreamWriter передать как параметр в метод TGraphic.SaveToStream. Кроме классов TBinaryWriter, TStreamWriter, в модуле AcedStreams имеются соответствующие им классы TBinaryReader, TStreamReader, предназначенные для чтения данных из бинарного потока.</P>
<P>Когда нужно прочитать данные из потока TBinaryReader, прежде всего нужно загрузить исходный массив с данными в память. Для этого используется один из следующих методов: LoadFromArray (загружает данные из массива байт, ссылка на который передана в качестве параметра), LoadFromBase64 (загружает данные из строки в кодировке Base64), LoadFromFile (загружает данные из файла, который был предварительно открыт и установлен в позицию, соответствующую началу блока данных), LoadFromStream (загружает данные из потока типа TStream). Все методы LoadFrom… принимают в качестве параметра ссылку на 256-битный ключ EncryptionKey. Если в этом параметре передан указатель на ключ, отличный от nil, при загрузке данных выполняется их дешифрование с указанным ключом и проверка целостности данных по сохраненному в потоке значению цифровой сигнатуры SHA-256. В классе TBinaryReader имеются методы для чтения из потока значений различного типа, включая String, Integer, TDateTime и т.д., а также метод Read, копирующий заданное число байт из бинарного потока в определенную область памяти. Если данные бинарного потока должны быть считаны некоторым стандартным классом, работающим только с потоками типа TStream, таким как класс TBitmap, нужно создать экземпляр класса TStreamReader, передав в его конструктор ссылку на соответствующий экземпляр TBinaryReader. После этого данные могут быть загружены методом TBitmap.LoadFromStream с передачей в него ссылки на созданный экземпляр TStreamReader.</P>
<P>Класс TBinaryWriter используется для помещения данных в бинарный поток, организованный в виде динамического массива. Данные записываются в поток методами WriteString, WriteInteger, WriteDateTime и т.п. Кроме того, метод Write позволяет скопировать в поток содержимое произвольной области памяти. Когда все необходимые данные помещены в бинарный поток, можно вызвать один из следующих методов: SaveToArray (представляет данные потока, возможно, сжатые и зашифрованные, в виде массива байт), SaveToBase64 (представляет данные в виде строки в кодировке Base64), SaveToFile (сохраняет данные в файле, дескриптор которого передан в качестве параметра), SaveToStream (сохраняет данные в потоке типа TStream). Все методы SaveTo… принимают параметр CompressionMode, который устанавливает режим сжатия бинарных данных перед помещением их в выходной массив (см. перечень констант, выбирающих режим сжатия, в описании модуля AcedCompression). Методы SaveTo… принимают также параметр EncryptionKey. Если он не равен значению nil, то должен содержать ссылку на 256-битный ключ, т.е. массив из 32 байт. В этом случае данные бинарного потока шифруются методом RC6 с указанным ключом. Кроме того, для них вычисляется значение цифровой сигнатуры SHA-256, которая также записывается в выходной массив и используется в дальнейшем при расшифровке данных для проверки их целостности. Ключ шифра передается параметром типа PSHA256Digest. Этот тип является своего рода подсказкой, что в качестве ключа при шифровании методом RC6 удобно использовать значение односторонней функции SHA-256, рассчитанное для ключевого массива байт или строки символов, вводимой пользователем с клавиатуры в качестве пароля.</P>
<H2>Модуль AcedStrings<A name="IDAUMGGD"></A></H2>
<P>AcedStrings содержит набор функций, предназначенных для работы со строками типа AnsiString. Кроме того, в этом модуле определен класс TStringBuilder, являющийся аналогом классов StringBuilder из .NET и Java. Рассмотрим подробнее, что полезного есть в этом модуле.</P>
<P>В AcedStrings находятся функции, реализующие быстрое сравнение строк с учетом или без учета регистра символов. Сравнение выполняется на больше-меньше или на равно - не равно. При сравнении могут учитываться все символы или только определенное число начальных символов строки. Следующая группа объединяет функции, используемые для преобразования строк и отдельных символов к верхнему или нижнему регистру. Далее следуют функции, которые облегчают работу со строками, сохраненными в кодировке MS-DOS. Они позволяют быстро менять кодировку строк с DOS на Windows и обратно. В процессе преобразования используются массивы перекодировки ToOemChars и ToAnsiChars, определенные в конце интерфейсного раздела модуля. Эти массивы по умолчанию соответствуют кодировке "Кириллица Win1251". Однако, используя небольшую программу, текст которой приведен в виде комментария в модуле AcedStrings, можно сформировать соответствующие таблицы для любой другой кодировки символов. Есть также возможность динамического формирования таблиц перекодировки в момент запуска программы на компьютере конечного пользователя в зависимости от текущих региональных настроек. Этот режим включается при определении символа USE_DYNAMIC_TABLES в коде модуля AcedStrings.</P>
<P>Следующая группа содержит функции поиска, замены, удаления подстрок и отдельных символов. Здесь находятся функции быстрого поиска подстрок с учетом и без учета регистра символов. Поиск выполняется с начала (функции G_PosStr/G_PosText) или с конца строки (функции G_LastPosStr/G_LastPosText). Для поиска отдельных символов служат функции G_CharPos и G_LastCharPos. Функция G_Paste заменяет фрагмент строки определенной длины, начиная с указанного символа, другим фрагментом. Функции: G_ReplaceStr, G_ReplaceText, G_ReplaceChar, G_ReplaceChars, G_ReplaceCharsWithOneChar используются для замены всех вхождений подстроки или некоторого символа в строке другой подстрокой или символом. Функции: G_Delete, G_CutLeft, G_CutRight, G_DeleteStr, G_DeleteText, G_DeleteChar, G_DeleteChars, G_KeepChars используются для удаления из строки фрагментов, подстрок или отдельных символов. Функции: G_Compact, G_Trim, G_TrimLeft, G_TrimRight удаляют из строки пробелы и управляющие символы.</P>
<P>Далее следуют функции для работы с маской. Под маской здесь понимается шаблон, подобный тому, который используется при поиске файлов на диске, как, например, "rpt??w?.xls" или "*.tmp". Функция G_ApplyMask форматирует строку символов с помощью маски, а G_ExtractWithMask, наоборот, извлекает данные из строки по маске; G_ValidateMask используется для проверки того, что строка удовлетворяет заданной маске; функции G_ValidateWildStr и G_ValidateWildText выполняют проверку соответствия строки заданному шаблону, который может содержать специальные символы, предполагающие замену их любым количеством произвольных символов, т.е. аналогичные символу '*' в шаблоне для поиска файлов.</P>
<P>Кроме перечисленных, в AcedStrings входят функции: G_CountOfChar, G_CountOfChars для подсчета числа вхождений одного или нескольких символов в строку; G_IsEmpty для проверки того, что строка является пустой или содержит только пробелы и управляющие символы; G_PadLeft, G_PadRight, G_Center для дополнения строки, соответственно, слева, справа или с обеих сторон указанным символом до требуемой длины; функция G_Duplicate формирует строку, состоящую из нескольких копий другой строки; G_StrReverse обращает порядок символов в строке.</P>
<P>Если для управления памятью в проекте используется менеджер памяти AcedMemory и в тексте модуля AcedStrings определен символ USE_ACED_MEMORY, становятся доступны функции G_NewStr, G_Append, G_AppendLine, G_Insert. Они могут использоваться в качестве альтернативы классу TStringBuilder для того, чтобы эффективно изменять и дополнять строки типа AnsiString на месте, без лишнего перераспределения памяти. Например, формирование длинной строки в цикле с помощью функции G_Append выполняется значительно быстрее простой конкатенации строк. Однако, этот способ все же менее эффективен, чем использование класса TStringBuilder, т.к. при каждом изменении строки тратится дополнительное время на определение размера области памяти, выделенной под строку. Функции типа G_Append, G_Insert лучше применять для внесения небольшого числа изменений в длинную строку, когда создание специального экземпляра класса TStringBuilder неоправданно.</P>
<H4>Класс TStringBuilder</H4>
<P>Этот класс предназначен для динамического создания строки из отдельных фрагментов и изменения строки произвольной длины. В принципе, можно изменять и дополнять обычную строку типа AnsiString. Однако при каждом дополнении такой строки происходит выделение памяти под новую строку и копирование в нее данных. Перераспределение памяти – это довольно медленная операция, независимо от используемого менеджера памяти. В экземпляре TStringBuilder строка, по возможности, изменяется на месте, без лишней перетасовки памяти. Например, если необходимо сформировать строку из элементов некоторого списка, то вместо того, чтобы по очереди добавлять строки к переменной типа String, лучше создать экземпляр класса TStringBuilder, добавить каждую строку из списка методом Append, а затем преобразовать результат к типу String вызовом метода ToString класса TStringBuilder.</P>
<P>В классе TStringBuilder реализованы основные методы для внесения изменений и дополнения строки. В частности, метод Append добавляет к данной строке другую строку, фрагмент строки, один или несколько повторяющихся символов, десятичное или шестнадцатеричное представление числа; метод Insert вставляет подстроку в указанную позицию; метод Delete удаляет фрагмент строки; метод Reverse обращает порядок символов во всей строке или в отдельном фрагменте; метод Clear очищает строку. Еще есть методы для создания копии экземпляра класса TStringBuilder (метод Clone), преобразования строки или ее фрагмента к типу AnsiString (метод ToString), заполнения фрагмента строки указанным символом (метод Fill), добавления в конец строки символов перевода строки (метод AppendLine) и другие. Свойство Chars класса TStringBuilder позволяет работать со строкой как с обычным массивом символов.</P>

<H2>Модуль AcedCommon<A name="IDAMNGGD"></A></H2>
<P>В AcedCommon собраны разнообразные функции, в том числе, для форматирования даты и времени, вычисления контрольной суммы Адлера и CRC-32 фрагмента данных, преобразования числа в строку и строки в число, записи числовых и денежных сумм прописью, замены символов строки шестнадцатеричными кодами этих символов и, наоборот, замены кодов символами, кодирования байтовых массивов и строк в Base64 и обратного их преобразования. Кроме того, здесь находятся функции для работы со счетчиками, таймером высокого разрешении, а также несколько вспомогательных функций.</P>
<H4>Форматирование даты и времени</H4>
<P>В начале модуля AcedCommon объявлены константные массивы, содержащие названия месяцев и дней недели, записанных по-русски и по-английски. Для форматирования даты используется функция G_FormatDate. Она возвращает дату представленную краткой числовой формой или полной формой, содержащей название месяца и слово "года". Строка-результат может включать также полное или краткое название дня недели или, вообще, состоять только из дня недели без даты. Функция G_SplitDate позволяет выделить из даты день месяца как числовое значение, а сам месяц и год представить в виде строки. Для форматирования времени используется функция G_FormatTime, которая преобразует время в строку по правилам русского языка с возможным указанием числа секунд и миллисекунд.</P>

<H4>Операции с числами типа Double и Currency</H4>
<P>Следующая группа объединяет функции для работы со значениями типа Double и Currency. В частности, процедуры G_Inc, G_Dec, G_Mult, G_Div принимают в качестве первого параметра ссылку на переменную типа Double или Currency и, соответственно, складывают, вычитают, умножают или делят ее значение на число, переданное вторым параметром. Эти процедуры призваны компенсировать собой отсутствие в языке Delphi операций "+=", "/=" и т.п. из C-подобных языков. Функцию G_ToDouble необходимо вызывать для приведения значения типа Currency к типу Double, т.к. обычный способ приведения: "Double(Currency)" не срабатывает из-за ошибки в компиляторе. Функция G_ThousandsToDouble преобразует значение типа Currency к типу Double, одновременно делит его на 1000 и округляет до 3-х знаков после запятой.</P>

<H4>Контрольная сумма Адлера и CRC-32</H4>
<P>Данная группа функций предназначена для вычисления контрольных сумм, используемых при проверке целостности данных. Контрольная сумма представляет собой число типа LongWord, которое зависит от всего исходного массива данных. При изменении хотя бы одного бита данных, значение контрольной суммы меняется. Это значение может, например, передаваться вместе с данными по сети, а затем пересчитываться на приемном конце и сравниваться с исходным значением контрольной суммы. Если оба значения равны, то с большой вероятностью можно утверждать, что данные переданы без ошибок. Здесь имеются в виду случайные ошибки при передаче, а не предумышленное искажение данных. Для надежной защиты данных от любого вида вмешательства вместо контрольной суммы нужно использовать цифровую сигнатуру, такую как SHA-256 (см. описание модуля AcedCrypto). Правда, значение односторонней функции SHA-256 рассчитывается медленнее, чем контрольная сумма типа CRC-32.</P>
<P>Функция G_Adler32 вычисляет контрольную сумму Адлера массива байт в соответствии с RFC 1950. Эта контрольная сумма применяется библиотекой сжатия zlib. Она получается быстрее, чем CRC-32, но, по всей видимости, является чуть менее надежной. Функции G_CRC32 и G_NextCRC32 возвращают значение контрольной суммы CRC-32 указанной области памяти. Вторая функция отличается от первой тем, что она используется для поэтапного расчета контрольной суммы массива, представленного в виде нескольких фрагментов. Например, если длинный массив передается по сети в виде нескольких пакетов, функция G_NextCRC32, вызываемая последовательно для каждого пакета данных, вычислит в результате контрольную сумму целого массива. Пара функций G_CRC32_Str и G_CRC32_Text может использоваться при хэшировании строк. Первая функция возвращает значение типа LongWord, которое зависит от всех символов строки с учетом их регистра. Вторая функция возвращает значение, которое зависит от всех символов строки, но не зависит от их регистра, т.е. это значение будет одинаковым для строк, которые отличаются только регистром символов.</P>

<H4>Преобразование числа в строку и строки в число</H4>
<P>В AcedCommon есть несколько функций для преобразования целого числа в строку, содержащую его десятичное или шестнадцатеричное представление (функции G_IntToStr, G_UIntToHex и др.). G_HexToUInt возвращает число типа LongWord, шестнадцатеричная запись которого передана параметром типа String. Функции G_Between… используются для проверки того, что число, записанное в виде строки, лежит в нужном диапазоне. Функции G_StrTo… выполняют преобразование строки в число, типа Integer, LongWord, Int64, Extended или Currency. В случае ошибки эти функции не генерируют исключение, а возвращают значение False. Еще есть функция G_ModDiv10, которая делит значение var-параметра на 10 и возвращает остаток от деления как результат функции. Она может быть полезна при преобразовании в строку длинных чисел.</P>
<P>Функции G_NumToStr и G_NumToRub используются для записи числовых и денежных сумм прописью по-русски. Различные особенности записи чисел прописью настраиваются соответствующими параметрами форматирования. Например, вызов G_NumToStr(54321, S, nfFemale) вернет в переменной S строку: "пятьдесят четыре тысячи триста двадцать одна", а вызов G_NumToRub(3.2, ruFull, ruNumShort) вернет строку: "Три рубля 20 коп.".</P>

<H4>Работа с кодировкой Base64 и шестнадцатеричными кодами</H4>
<P>В этом модуле находятся функции для работы с кодировкой Base64, представляющие строку символов или массив байт в виде новой строки, не содержащей пробелов, управляющих символов и символов в национальной кодировке. Функция G_Base64Encode выполняет кодирование строки символов или массива байт в Base64. Результат возвращается в виде строки типа AnsiString. Обратное преобразование выполняется функцией G_Base64Decode, которая восстанавливает исходный массив байт или строку символов из строки в кодировке Base64. В версии 1.12 библиотеки AcedUtils алгоритм работы этих функций изменен, чтобы соответствовать общепринятому стандарту.</P>
<P>Кроме того, здесь находятся функции, позволяющие представить строку символов в виде строки шестнадцатеричных кодов символов. Функция G_StrToCodes возвращает строку, в которой каждый символ исходной строки, переданной параметром, заменен соответствующим шестнадцатеричным кодом. Например, вызов G_StrToCodes('ABC') вернет строку: "414243". Функция G_CodesToStr используется для обратного преобразования: G_CodesToStr('414242') вернет строку "ABC".</P>

<H4>Функции для замера временных интервалов</H4>
<P>Когда в программе нужно отмерить временные интервалы, можно воспользоваться стандартной функцией GetTickCount из модуля Windows, которая возвращает число миллисекунд, прошедшее с момента загрузки операционной системы. Поскольку это значение выражается числом типа LongWord, со временем оно может переполниться и пойти на следующий "круг". Функция G_TickCountSince из модуля AcedCommon учитывает эту особенность и возвращает число миллисекунд, прошедшее с того момента, как функция GetTickCount вернула значение Tick, передаваемое в качестве параметра в G_TickCountSince. Хотя GetTickCount возвращает число миллисекунд, точность этой функции не превышает 0.1 секунды. Когда нужно отмерить интервал с точностью до одной миллисекунды можно воспользоваться таймером высокого разрешения. Получить текущее значение таймера можно вызовом функции G_QueryPC, которая возвращает значение, полученное вызовом системной функции QueryPerformanceCounter. По разности значений таймера можно определить длительность временного интервала с помощью функции G_GetTimeInterval. Кроме того, с помощью функции G_GetPC_Delta можно, наоборот, вычислить разность значений таймера, соответствующую временному интервалу определенной длительности.</P>
<P>К замеру временных интервалов с помощью таймера высокого разрешения имеет смысл прибегать, только когда требуется высокая точность. В остальных случаях лучше вызывать функции GetTickCount и G_TickCountSince, т.к. они используют меньше ресурсов системы. В модуле AcedCommon имеется также функция G_RDTSC, считывающая значение 64-разрядного счетчика, который увеличивается на каждом такте процессора. В некоторых случаях эта функция может заменить собой таймер высокого разрешения. Кроме того, она может быть полезна при инициализации генератора псевдослучайных чисел.</P>

<H4>Прочие функции</H4>
<P>Функция G_SwitchToApplication переводит на передний план запущенный экземпляр приложения, к которому принадлежит окно с указанным именем класса. Обычно эта функция применяется для предотвращения повторного запуска приложения, чтобы вместо запуска нового экземпляра вывести на передний план запущенный ранее экземпляр приложения. Кроме того, ее можно использовать, например, для переключения на другую задачу при организации приложения в виде нескольких независимых процессов. Функция G_SelectMenu используется для имитации выбора пользователем заданного пункта или подпункта меню текущего окна. При этом в функцию окна посылаются события, имитирующие нажатие пользователем клавиши вызова меню, клавиш со стрелками вправо и вниз, клавиши Enter, в последовательности, необходимой для выбора нужного пункта меню. При этом глубина раскрываемого подпункта может быть любой. Функции G_ToggleKey и G_IsToggled управляют состоянием клавиш: Num Lock, Caps Lock, Scroll Lock. Первая функция позволяет изменить состояние любой из этих клавиш, вторая – считывает текущее состояние соответствующей клавиши. Последняя функция G_ODS помещает сообщение в Event Log (журнал, вызываемый из отладчика в среде Borland Delphi по Ctrl+Alt+V).</P>

<H2>Модуль AcedCompression<A name="IDACPGGD"></A></H2>
<P>В модуле AcedCompression находятся функции, предназначенные для сжатия бинарных данных методом Зива-Лемпела с последующим преобразованием в код Хаффмана. Эта реализация немного отличается от метода сжатия, используемого в библиотеке AcedUtils.NET. Упаковка данных осуществляется функцией G_Deflate, которая принимает в качестве параметра Mode одну из следующих констант, выбирающих режим сжатия:</P>
<UL style="LIST-STYLE:square"><LI><STRONG>dcmNoCompression</STRONG> – данные не сжимаются, просто копируются в выходной массив. Функция G_Deflate переключается в этот режим автоматически, если сжимаемые данные не содержат избыточности, например, если они зашифрованы или упакованы другим методом. Размер исходного массива увеличивается при этом на 4 байта, в которых сохраняется длина исходного массива. Таким образом, 4 байта – это максимальная величина, на которую увеличивается длина исходного массива в случае невозможности его сжатия.</LI>
<LI><STRONG>dcmFastest</STRONG> – используется, когда надо сжать данные максимально быстро. При этом качество сжатия во многом зависит от характера самих данных. Если они содержат большое число повторяющихся фрагментов, использование этого режима нерационально, т.к. в нем применяется "облегченный" вариант словарного метода сжатия (Зива-Лемпела). Сжатие Хаффмана, наоборот, реализовано в полной мере. Оно основано на разности частот появления отдельных кодов символов. Если к исходным данным применим такой способ упаковки и они содержат мало повторяющихся последовательностей, режим dcmFastest может оказаться даже более эффективным, чем режим dcmMaximumCompression, за счет большей дисперсии частот отдельных кодов. Это справедливо, например, при сжатии wav-файлов, для которых, впрочем, данный алгоритм в принципе малоэффективен. Такие данные лучше сжимать другими средствами. Максимальное расстояние между повторяющимися последовательностями байт в этом режиме принимается равным 8191 байту.</LI>
<LI><STRONG>dcmFast</STRONG> – обычная степень сжатия, достигаемая за минимальное время. Вероятно, данный режим является оптимальным при сжатии бинарных данных. В этом случае использование режимов dcmNormal и dcmMaximumCompression приводит к уменьшению размера выходного массива на 1-2%, но время сжатия возрастает в несколько раз. В режиме dcmFast максимальное расстояние между повторяющимися фрагментами данных равно 65535 байт.</LI>
<LI><STRONG>dcmNormal</STRONG> – обычно соответствует хорошей степени сжатия. Его можно использовать для данных с большим числом повторяющихся фрагментов, например, текстов или doc-файлов. Максимальное расстояние между повторяющимися группами байт принимается равным 262143 байт.</LI>
<LI><STRONG>dcmMaximumCompression</STRONG> – в этом режиме достигается максимальная степень сжатия, доступная для реализованного в модуле AcedCompression алгоритма. В большинстве случаев, однако, режим dcmNormal почти не уступает режиму dcmMaximumCompression по степени сжатия и значительно превосходит его по скорости.</LI>
</UL>
<P>В модуле AcedCompression есть два варианта функции G_Deflate. В первом варианте функция сама распределяет память под массив, достаточный для хранения упакованных данных. Во втором варианте массив должен быть создан заранее, а функция G_Deflate только заполняет его данными.</P>
<P>Имеются также функции для распаковки сжатого массива данных. Размер исходного массива можно получить вызовом функции G_GetInflatedLength, а сама распаковка данных выполняется функцией G_Inflate. Имеется два варианта этой функции. В первом варианте память под массив, содержащий выходные данные, распределяется функцией G_Inflate. Во втором варианте, массив для хранения распакованных данных должен быть создан заранее размером не менее, чем длина, которую вернул вызов функции G_GetInflatedLength для упакованного массива данных. Следует отметить, что используемый режим сжатия не влияет на скорость распаковки данных, кроме режима dcmNoCompression, при котором данные просто копируются с одного места в другое.</P>
<H2>Модуль AcedCrypto<A name="IDAFYGGD"></A></H2>
<P>Модуль объединяет функции, используемые для шифрования и верификации данных, а также для генерации псевдослучайных чисел.</P>
<P>Функции G_RC4… предназначены для шифрования данных методом RC4. Это широко распространенный поточный шифр. Возможно, по стойкости он уступает блочным шифрам, типа Rijndael или CAST, но, зато, значительно превосходит их по производительности. Не так давно в этом шифре было обнаружено несколько уязвимостей, которые касаются алгоритма заполнения внутреннего массива ключей (key scheduling algorithm). Чтобы избежать связанной с этим гипотетической опасности взлома зашифрованных данных, компания RCA, разработчик данного шифра, рекомендует пропускать первые 256 байт выходной псевдослучайной последовательности. Функции из модуля AcedCrypto написаны с учетом этого замечания. При правильном использовании метод RC4 является вполне надежным. Надо только помнить основную особенность поточных шифров – один и тот же ключ не должен применяться для шифрования различных данных. Например, ключ может вычисляться с помощью побитовой операции xor двух чисел, одно из которых является постоянным и рассчитывается как цифровая сигнатура пароля, вводимого пользователем с клавиатуры, а второе число является изменяемым и создается генератором псевдослучайных чисел перед каждым сеансом шифрования данных. Изменяемое число может сохраняться в первых байтах зашифрованного потока данных.</P>
<P>Следующий набор функций из AcedCrypto – G_RC6… предназначен для шифрования данных методом RC6. Это блочный шифр, разработанный компанией RCA. Нормальная длина ключа при шифровании методом RC6 составляет 256 бит (32 байта). В AcedCrypto имеются функции для инициализации процесса шифрования, задания начального вектора, шифрования и дешифрования 128-битного блока данных в режиме ECB (электронная кодовая книга), шифрования и дешифрования произвольного массива байт в режимах CFB (обратная загрузка шифротекста) и OFB (обратная загрузка выходных данных) с размером блока 128 бит. В режимах CFB и OFB размер шифруемых и дешифруемых фрагментов данных должен совпадать или размер этих фрагментов должен быть кратен 16 байт. При использовании в качестве ключа шифра пароля, вводимого пользователем с клавиатуры, нужно передавать в функцию G_RC6Init в качестве ключа не саму строку, содержащую введенный пароль, а цифровую сигнатуру SHA-256, рассчитанную для строки, введенной пользователем.</P>
<P>Далее в модуле AcedCrypto находятся функции, предназначенные для расчета значения односторонней хэш-функции SHA-256 массива байт. Цифровая сигнатура SHA-256 представляет собой массив из 32 байт, который вычисляется по данным исходного массива байт таким образом, чтобы, во-первых, невозможно было подобрать другой массив байт, для которого значение сигнатуры совпало бы с данной сигнатурой, и, во-вторых, чтобы по значению цифровой сигнатуры невозможно было восстановить какие-либо значения из исходного массива байт. Алгоритм расчета SHA-256 реализован в соответствии с документом FIPS180-2. Не так давно была опубликована информация о нахождении уязвимости в алгоритме хэш-функции SHA-1. В связи с этим следует отметить, что алгоритм SHA-256 во многом отличается от SHA-1 и об успешных атаках на SHA-256 до сих пор ничего не известно. В модуле AcedCrypto имеются функции для расчета цифровой сигнатуры для массива байт и строки символов. Кроме того, можно рассчитать сигнатуру для массива байт, представленного в виде нескольких фрагментов. Это удобно, например, при работе с данными, организованными в виде потока типа TStream. </P>
<P>Функции G_Random… реализуют генератор псевдослучайных чисел типа Mersenne Twister, период которого можно считать равным бесконечности. Функция G_RandomNext возвращает число типа LongWord, равномерно распределенное в интервале от 0 до $FFFFFFFF; функция G_RandomUniform генерирует псевдослучайную величину, равномерно распределенную в интервале [0.0, 1.0]; G_RandomGauss используется для моделирования непрерывной случайной величины с нормальным законом распределения. Функция G_RandomFill позволяет заполнить область памяти псевдослучайной последовательностью байт. Функция G_RandomEncryptVector шифрует внутренний вектор, используемый при генерации псевдослучайных чисел, методом RC6. Это соответствует переводу генератора на новую числовую последовательность. Сама по себе выходная числовая последовательность данного генератора не является криптографически стойкой. Чтобы превратить ее в криптографически стойкую, можно воспользоваться, например, функцией G_SHA256Transform.</P>
<H2>Модуль AcedAlgorithm<A name="IDATYGGD"></A></H2>
<P>Модуль объединяет функции для работы с набором данных, представленным в виде массива указателей. Такие массивы удобны для представления в памяти различных временных списков, которые могут содержать ссылки на сохраняемые объекты типа TSerializableObject, указатели на записи, используемые в процессе группирования данных при построении отчетов, и т.п. Работать с массивами указателей удобно посредством класса TArrayList из модуля AcedContainers. Но класс TArrayList содержит методы для выполнения только самых основных операций с данными. Большое число других операций реализуется функциями из модуля AcedAlgorithm. Применить любые из этих функций к данным, содержащимся в наборе TArrayList, можно работая со свойствам ItemList и Count класса TArrayList. Рассмотрим структуру модуля AcedAlgorithm.</P>
<P>В начале модуля располагаются функции G_Search и G_SearchBackward для линейного поиска в массиве. Искомое значение Value передается в эти функции как указатель. Кроме того, одним из параметров является адрес функции типа TMatchFunction, предназначенной для сопоставления значения элементу массива. Функция G_Search производит последовательный поиск, начиная с первых элементов массива, G_SearchBackward – поиск назад, начиная с последних элементов массива. Функция G_Replace находит в массиве все элементы, равные значению Value, и заменяет их новым элементом, который передается в качестве параметра функции. G_CountOf подсчитывает количество элементов, равных искомому значению. Функция G_RemoveCopy копирует в новый массив все элементы из исходного массива, кроме тех, которые равны значению Value. Еще есть функции для удаления смежных дубликатов элементов. Далее следуют функции для поиска минимального и максимального элементов массива. Функции G_SearchMin и G_SearchMax возвращают сам минимальный или максимальный элемент, а G_IndexOfMin и G_IndexOfMax – индекс минимального или максимального элемента. Когда требуется найти сразу и минимум и максимум в массиве элементов, вместо того, чтобы вызывать сначала G_SearchMin, а потом G_SearchMax, лучше воспользоваться функцией G_SearchMinMax, которая оптимизирована для такого случая.</P>
<P>Следующие функции предназначены для переупорядочивания элементов массива по различным критериям. Функция G_Rotate перемещает все элементы массива, начиная с указанного индекса и до конца массива, в начало массива, а элементы с начала до указанного индекса – в конец массива. G_RotateCopy аналогична G_Rotate, но сохраняет результат в новом массиве и выполняется немного быстрее, чем G_Rotate. Функция G_PartitionStrict перемещает все элементы массива, меньшие заданного значения, в начало массива. Остальные элементы перемещаются в конец массива. G_PartitionUnstrict отличается от G_PartitionStrict только условием ("меньше или равно" вместо "меньше") перемещения элементов в начало массива. Имеются также аналоги этих функций с приставкой Stable (G_StablePartitionStrict и G_StablePartitionUnstrict). Они отличаются тем, что при перемещении элементов сохраняется их относительный порядок до и после значения Value. Функция G_SelectTop перемещает N минимальных элементов в начало массива. Остальные элементы перемещаются в конец массива. Эта функция работает подобно алгоритму Nth_element из STL. Функция G_StableSelectTop выполняет то же действие, но без нарушения относительного порядка элементов в левой и правой частях массива, т.е. до и после N-го элемента. При небольшом объеме данных "stable" и "nonstable" варианты функций почти не отличаются по скорости работы, но для поддержания относительного порядка элементов приходится задействовать дополнительную память в размере, занимаемом исходным массивом указателей. Функция G_RandomShuffle перемешивает массив указателей с помощью генератора псевдослучайных чисел.</P>
<P>Далее следуют функции для сортировки массива по возрастанию значений элементов. Элементы массива сравниваются между собой с помощью функции типа TCompareFunction, адрес которой передается в качестве параметра во все процедуры сортировки. Самая быстрая сортировка большого объема данных выполняется процедурой G_Sort, реализующей метод интроспективной сортировки. Данный алгоритм представляет собой модификацию алгоритма быстрой сортировки, которая предусматривает выбор для каждого диапазона среднего значения из трех вариантов: начало, середина и конец диапазона. Кроме того, если подбираются исходные данные, критичные для алгоритма быстрой сортировки, и его сложность достигает O(N<SUP>2</SUP>), функция G_Sort заменяет быструю сортировку пирамидальной, сложность которой всегда O(N*Log(N)). Когда нужно отсортировать данные без изменения относительного порядка равных элементов, пригодится функция G_StableSort, реализующая метод сортировки слиянием. В отличие от интроспективной сортировки, данный метод требует выделения дополнительной памяти размером, равным размеру сортируемого массива указателей. Если нужно отсортировать не весь массив, а только первые (наименьшие) N элементов, можно воспользоваться функцией G_PartialSort или G_PartialSortCopy, основанными на алгоритме пирамидальной сортировки. Проверить, является ли массив отсортированным по возрастанию можно с помощью функции G_IsSorted.</P>
<P>В AcedAlgorithm имеются функции для бинарного поиска элементов в массиве, отсортированном по возрастанию искомого признака. Функция G_BinarySearch возвращает индекс элемента, значение которого равно заданному. G_SearchFirstGreater (G_SearchFirstGreaterOrEqual) возвращает индекс первого элемента массива, значение которого больше (больше или равно) искомому значению. G_SearchLastLesser (G_SearchLastLesserOrEqual)  возвращает индекс последнего элемента в отсортированном массиве, значение которого меньше (меньше или равно) искомого значения. Также имеются функции для слияния сортированных массивов элементов. Первая из них – G_Merge создает из двух отсортированных массивов новый массив, состоящий из всех элементов исходных массивов, который также является отсортированным по возрастанию. Другие функции объединяют массивы подобно тому, как различные логические операции применяются ко множествам. Например, функция G_SetIntersection сохраняет в выходном массиве пересечение исходных массивов, т.е. только те элементы, которые присутствуют в обоих исходных массивах.</P>
<P>Последняя группа функций в этом модуле предназначена для работы с кучей. Куча представляет собой бинарное дерево в виде последовательной коллекции элементов. Причем значение каждого узла такого бинарного дерева больше или равно значениям его дочерних узлов. Куча обладает следующими свойствами: первый элемент кучи всегда является максимальным элементов в массиве, добавление и удаление элементов кучи выполняется с логарифмической сложностью. На основе куч могут создаваться приоритетные очереди элементов. Кроме того, механизм куч лежит в основе алгоритмов пирамидальной и частичной сортировки элементов массива. Процедура G_MakeHeap переупорядочивает массив так, чтобы он представлял собой кучу. G_PushHeap помещает значение в кучу. G_PopHeap извлекает значение из кучи. G_SortHeap сортирует элементы кучи по возрастанию, т.е. превращает кучу в обычный сортированный массив. Функция G_IsHeap проверяет, является ли массив элементов кучей.</P>
<H2>Модуль AcedContainers<A name="IDAFZGGD"></A></H2>
<P>Модуль содержит классы, являющиеся контейнерами данных.</P>
<H4>Битовая строка TBitList</H4>
<P>Предоставляет методы и свойства для работы со строкой бит, которую можно представить как упакованный набор элементов типа Boolean. Изначально, при создании экземпляра класса TBitList вызовом конструктора Create, все биты строки устанавливаются в 0 (False) или 1 (True), в зависимости от значения, переданного в параметре InitValue конструктора. Метод Load используется для загрузки битовой строки из бинарного потока типа TBinaryReader, произвольной области памяти или другого экземпляра класса TBitList. Кроме того, данные могут быть загружены из ключа реестра Windows. Для сохранения данных в бинарном потоке типа TBinaryWriter или в реестре Windows предназначен метод Save. Загрузить битовую строку из обычной строки, состоящей из символов '0' и '1', можно с помощью метода FromString. Наоборот, чтобы представить битовую строку в виде обычной строки, надо воспользоваться функцией ToString.</P>
<P>К отдельным элементам битовой строки можно обратиться с помощью свойства Bits. Изменить состояние отдельных битов можно также методами SetBit, ResetBit и ToggleBit. Общее число элементов возвращается и устанавливается свойством Count. Функция Contains проверяет наличие в битовой строке элемента с указанным значением (True или False). Методы IndexOf, LastIndexOf используются для поиска, соответственно, вперед и назад первого установленного или сброшенного бита, начиная с указанного индекса. Функция CountOf подсчитывает общее количество установленных или сброшенных бит в массиве. Метод SetAll устанавливает все биты в значение 0 или 1. Если два экземпляра класса TBitList содержат одинаковое число элементов, к ним можно применить различные логические операции. Например, метод AndBits выполняет операцию логического умножения элементов двух списков. В результате, установленными окажутся только биты, которые были установлены в обоих списках, а все остальные биты будут установлены в 0. Аналогичные методы предусмотрены для выполнения операций: OR, XOR, NOT, AND NOT. Функция Equals используется для проверки равенства содержимого двух экземпляров класса TBitList. Функция Clone возвращает копию экземпляра TBitList.</P>

<H4>Классы TIntegerList, TWordList</H4>
<P>Эти классы предназначены для работы со списком значений типа Integer или Word, соответственно. Классы полностью аналогичны друг другу, поэтому рассмотрим только первый из них – TIntegerList. Список значений может быть сортированным или несортированным. Это зависит от свойства MaintainSorted. Если оно равно True, при выполнении операций добавления и удаления элементы списка гарантированно располагаются в порядке возрастания значений. Если свойство MaintainSorted равно False, новые элементы добавляются в конец списка, независимо от их значений. В этом случае допустимо использовать метод Insert для вставки одного или нескольких элементов в произвольное место списка. Кроме того, можно использовать метод UnorderedRemoveAt для быстрого удаления элементов списка. При вызове данного метода удаляемый элемент замещается последним элементом списка, после чего свойство Count уменьшается на 1. Таким образом, удаление элемента происходит без смещения всех следующих за ним элементов списка. Когда MaintainSorted равно True, при вызове методов Insert и UnorderedRemoveAt возникает исключение, т.к. произвольная вставка и unordered-удаление могут нарушить порядок сортировки элементов.</P>
<P>Для поиска значений в списке применяется метод IndexOf, который возвращает индекс найденного элемента или -1, если искомый элемент отсутствует. Когда элементы списка отсортированы, используется быстрый алгоритм бинарного поиска, в противном случае – линейный поиск с помощью функции G_Scan_Integer из модуля AcedBinary. Иногда бывает удобнее не поддерживать список все время в отсортированном виде, так как это замедляет процесс вставки и удаления элементов. Вместо этого перед началом поиска можно вызвать метод EnsureSorted. Тогда, если список не был отсортирован, он сортируется, а затем выполняется быстрый бинарный поиск. Естественно, это имеет смысл делать, только если поиск выполняется многократно, т.к. сама сортировка занимает больше времени, чем линейный поиск.</P>
<P>Аналогично классу TBitList, в TIntegerList есть методы для загрузки списка из бинарного потока типа TBinaryReader, из произвольной области памяти, из реестра Windows или из другого экземпляра класса TIntegerList. Список может быть сохранен в бинарном потоке TBinaryWriter или в реестре Windows. Кроме того, список может быть загружен из строки, содержащей данные в кодировке Base64, и может быть сохранен в виде строки в кодировке Base64. Новые элементы обычно добавляются в список методами Add или AddIfNotExists, когда необходимо избежать дублирования значений в списке. Чтобы удалить элемент из списка по индексу, вызывается метод RemoveAt, а чтобы удалить все элементы с определенным значением – метод Remove. При удалении значений методами Remove и RemoveAt порядок остающихся в списке элементов не меняется. Список полностью очищается при вызове метода Clear. Функция Equals позволяет поэлементно сравнить два списка, а функция Clone возвращает копию данного экземпляра класса TIntegerList.</P>
<P>Когда свойство MaintainSorted равно False, экземпляр TIntegerList можно использовать в качестве стека. Значения помещаются в стек (в конец списка) методом Add, а извлекаются из стека (с конца списка) методом PopBack в соответствии с правилом: "первым вошел – последним вышел". Получить последнее значение, помещенное в стек, без его удаления можно методом PeekBack. Обратиться к отдельным элементам списка можно через свойство ItemList, которое возвращает указатель на массив элементов типа Integer. Число используемых элементов в этом массиве определяется свойством Count. Количество элементов, под которое распределена память во внутреннем массиве, считывается и устанавливается свойством Capacity. Начальное значение этого свойства передается как параметр в конструктор класса TIntegerList.</P>
<P>При описании модуля AcedBinary были рассмотрены функции, позволяющие работать с массивами чисел типа Integer как с множествами, в частности, применять к ним различные логические операции. Эти операции можно производить и с экземплярами класса TIntegerList. Например, пусть имеется два отсортированных списка значений типа Integer List1 и List2, из которых необходимо получить третий список List3, содержащий значения, присутствующие в первом списке, но отсутствующие во втором. Это соответствует операции вычитания множеств. Можно создать новый экземпляр класса TIntegerList для хранения списка-результата List3, передав в его конструктор число элементов первого списка, т.к. это число соответствует максимальной длине выходного массива для случая, когда два исходных множества не имеют пересечения. Операция вычитания множеств и заполнения списка List3 выполняется одной строкой кода:</P>
<P>List3.Count := G_SetDifference_Integer(List1.ItemList, List1.Count, List2.ItemList, List2.Count, List3.ItemList).</P>

<H4>Список указателей TArrayList</H4>
<P>TArrayList является аналогом класса ArrayList из .NET Framework. Он представляет собой динамический массив указателей. В конструктор класса передается предполагаемое число элементов, которое будет добавлено в список. Элементы можно загрузить методом Load из другого экземпляра класса TArrayList или из произвольной области памяти. Отдельные элементы добавляются методом Add в конец списка или методом Insert в произвольное место списка. Для удаления одного или нескольких элементов по индексу используется метод RemoveAt. Метод UnorderedRemoveAt позволяет быстро удалить элемент из списка, заменив его последним элементом списка и уменьшив на 1 значение свойства Count. Он может применяться, когда порядок элементов не имеет значения. Для полной очистки списка предназначен метод Clear. Аналогично классам TIntegerList, TWordList, в классе TArrayList имеются методы для работы со списком как со стеком. Метод PopBack возвращает последний элемент списка и одновременно удаляет его, уменьшая на 1 значение свойства Count. Метод PeekBack возвращает последний элемент списка, не удаляя его. Поместить элемент в стек можно с помощью метода Add.</P>
<P>Обращение к отдельным элементам списка осуществляется через свойство ItemList, которое возвращает ссылку на массив указателей типа Pointer. Длина списка возвращается свойством Count. Общее число элементов, под которое распределена память во внутреннем массиве, определяется свойством Capacity. Свойство Count может произвольным образом изменяться. Никаких проверок при этом не выполняется. Capacity обычно превышает Count, что позволяет добавлять новые элементы в список без немедленного выделения нового блока памяти. Чтобы предельно уменьшить объем памяти, занимаемый списком, можно вызвать метод TrimToSize, который распределяет под внутренний массив область памяти, достаточную для хранения Count элементов, но не более того. После вызова этого метода свойство Capacity становится равно свойству Count. Метод Clone возвращает копию экземпляра класса TArrayList. Метод Equals поэлементно сравнивает текущий список с заданным списком и возвращает True, если все элементы обоих списков равны, или False, если между списками есть какие-либо различия.</P>
<P>Свойство OwnItems класса TArrayList управляет принадлежностью элементов списку. Если это свойство равно True, при удалении элементов из списка, например, методом RemoveAt или Clear, каждый из них приводится к типу TObject и для него вызывается метод Free.</P>
<P>Чтобы найти элемент в списке TArrayList можно воспользоваться функцией ScanPointer, которая сканирует внутренний массив в поисках нужного указателя. Если надо найти не просто указатель, а элемент с определенным значением признака, необходимо воспользоваться функциями Search (возвращает искомый элемент списка) или IndexOf (возвращает индекс искомого элемента списка). Для более эффективного поиска, а также просто для упорядочивания элементов списка, можно отсортировать список методом Sort. Данный метод принимает в качестве параметра адрес функции, сравнивающей два элемента списка. Элементы сортируются по возрастанию. Кроме того, есть метод StableSort, который аналогичен методу Sort, но при сортировке сохраняет относительное расположение равных элементов списка. Однако, метод StableSort выделяет дополнительную память в объеме, равном размеру сортируемого массива указателей. После того, как список отсортирован, функции Search и IndexOf могут использовать эффективный метод бинарного поиска (при передаче True в параметре Sorted).</P>
<P>В классе TArrayList предусмотрена возможность группирования элементов. При этом элементы с одинаковым значением признака объединяются в одну группу. Группирование выполняется методом EnumerateGroups, который принимает в качестве параметра адрес функции, сравнивающей два элемента списка. При выполнении этой операции список сортируется в порядке возрастания значения признака. Функция EnumerateGroups возвращает коллекцию групп – экземпляр класса TGroupEnumerator. Число групп в этой коллекции определяется свойством GroupCount. Указатель на массив, содержащий группы, возвращается свойством GroupList класса TGroupEnumerator. Каждая группа представляется списком TArrayReadOnlyList – аналог класса TArrayList, который не позволяет добавлять и удалять элементы. Следует обратить внимание на то, что в экземпляре класса TArrayReadOnlyList нет собственного внутреннего массива для хранения элементов списка. Вместо этого он пользуется внутренним массивом экземпляра класса TArrayList, для которого был вызван метод EnumerateGroups. Поэтому в процессе работы с группами нельзя вносить изменения в основной экземпляр TArrayList.</P>

<H4>Ассоциативные списки</H4>
<P>Экземпляры классов: TIntegerAssociationList, TStringAssociationList, TIntegerHashtable, TStringHashtable представляют собой набор ключей типа Integer или String, с каждым из которых связано значение типа Pointer или TObject. Они предназначены для быстрого поиска значений в списке по ключу. Классы типа AssociationList хранят ключи в виде сортированного списка. Классы типа Hashtable реализуют ассоциативный массив с использованием хэширования ключей. Вероятно, сортированный список лучше подходит для небольших наборов данных в пределах одной-двух сотен элементов, когда накладные расходы на хэширование не оправданны. Хэш-таблицы можно применять для больших наборов данных, т.к. скоростные характеристики хэш-таблицы близки к O(1) (константны).</P>
<P>Во всех классах реализованы методы для добавления и удаления элементов (методы Add и Remove), извлечения значения по ключу (свойство Items). Свойство OwnValues управляет принадлежностью значений спискам. Например, если оно равно True, при очистке списка методом Clear, каждое значение приводится к типу TObject и для него вызывается метод Free. По умолчанию свойство OwnValues равно False и метод Free для значений не вызывается. В конструктор классов TStringAssociationList, TStringHashtable можно передать параметр, определяющий, нужно ли различать регистр символов в значениях ключей типа String. Чтобы заранее распределить память под известное число элементов, добавляемых в ассоциативный список, следует передать соответствующее значение в конструктор класса или воспользоваться методом EnsureCapacity.</P>

<H4>Красно-черные деревья</H4>
<P>Классы TStringRedBlackTree, TIntegerRedBlackTree, TInt64RedBlackTree реализуют специальный вид бинарного дерева поиска, которое называется красно-черным деревом. Его особенность заключается в том, что оно все время находится в относительно сбалансированном состоянии. Красно-черные деревья хорошо приспособлены как для изменения количества элементов, так и для поиска. Они гарантируют, что вставка потребует не более двух изменений внутренних ссылок, а самый длинный путь к элементу будет не более чем вдвое длиннее самого короткого. В узлах дерева находятся ключи и связанные с ними значения типа Pointer или TObject. Перечисленные классы отличаются друг от друга только типом используемых ключей: String, Integer или Int64. Красно-черные деревья могут применяться в качестве ассоциативных списков наряду с другими классами. В каждом случае выбирать структуру для хранения данных надо в зависимости от характера самих данных и применяемых к ним операций. Например, для большого набора данных добавление и удаление отдельных элементов эффективнее выполняется с помощью дерева по сравнению с ассоциативным списком типа AssociationList. В то же время, узлы дерева упорядочены по возрастанию значения ключа, что выгодно отличает деревья от более быстрых хэш-таблиц.</P>
<P>Новые узлы добавляются в красно-черное дерево методом Add. Узел с одним и тем же ключом не может быть добавлен дважды. Чтобы считать, изменить или добавить значение типа Pointer, ассоциированное с ключом, можно воспользоваться свойством Items. Это свойство индексируется значением ключа. Метод Remove позволяет удалить узел дерева по известному значению ключа. Кроме того, узел удаляется, если передать указатель на него в метод RemoveNode. Найти узел по значению ключа можно с помощью функции SearchNode. Чтобы найти узел, значение ключа в котором больше (больше или равно) заданного значения, применяется функция SearchFirstGreater (SearchFirstGreaterOrEqual). Соответственно, чтобы найти последний узел со значением ключа меньшим (меньшим или равным) заданному, вызывается функция SearchLastLesser (SearchLastLesserOrEqual). В классах типа RedBlackTree имеется несколько свойств и методов для осуществления навигации по дереву. Свойство Root возвращает корневой узел дерева. Свойства FirstNode и LastNode возвращают указатели на узлы, которые содержат, соответственно, наименьшее и наибольшее значения ключа. Перейти к узлу, содержащему следующее (по возрастанию) значение ключа, можно с помощью функции NextNode, а к предыдущему значению – с помощью функции PreviousNode.</P>

<H4>Связанный список TLinkedList</H4>
<P>Список TLinkedList представляет собой упорядоченный набор элементов, каждый из которых содержит ссылку на предыдущий и последующий элементы. Связанный список удобен для последовательного перебора элементов вперед или назад, а также для добавления и удаления элементов в произвольном месте списка. Этот класс может использоваться, например, для организации очередей, работающих по принципу: "первым пришел – первым вышел", с возможностью добавления элементов в конец очереди и выборки их с начала очереди. Особенностью списка на основе класса TLinkedList является отсутствие возможности индексированного доступа к элементам и свойства, возвращающего количество элементов в списке. Это сделано, чтобы предотвратить случаи неправильного использоваться данного класса. При необходимости обращения к элементам списка по индексу лучше воспользоваться другими классами, такими как TArrayList.</P>
<P>Свойство HeadNode экземпляра класса TLinkedList возвращает указатель на первый элемент, т.е. узел, списка. В противоположность этому свойству, TailNode возвращает указатель на последний элемент списка. С помощью этих свойств, а также полей NextNode и PrevNode узла списка TLinkedListNode, представляющих, соответственно, указатель на следующий и предыдущий элементы списка, можно перебрать все элементы списка. Значение типа Pointer узла списка сохраняется в поле Value записи TLinkedListNode. Если свойство OwnValues данного экземпляра TLinkedList равно True, при очистке списка методом Clear или удалении отдельных элементов методами RemoveHead, RemoveTail или Remove, значение Value каждого удаляемого узла списка приводится к типу TObject и для него вызывается метод Free. По умолчанию свойство OwnValues равно False, и метод Free для значений не вызывается. Добавить значение в начало или в конец связанного списка можно, соответственно, функциями AddHead и AddTail, которые возвращают ссылку на добавленный узел. Чтобы вставить значение в произвольное место списка, необходимо воспользоваться функциями InsertBefore или InsertAfter, добавляющими новый элемент перед или после определенного узла списка. Одноименные методы: AddHead, AddTail, InsertBefore, InsertAfter переносят один или несколько узлов из другого или того же списка в новый связанный список или в новое положение. При этом на старом месте узлы удаляются, а на новом появляются без лишнего перераспределения памяти. Функция IsEmpty возвращает True, если список пустой. Функции PopHeadValue, PopTailValue и PopValue возвращают значение, соответственно, первого, последнего и произвольного узлов, а сами узлы удаляют из связанного списка.</P>

<H4>Обычные и приоритетные очереди</H4>
<P>Обычные очереди представлены в AcedUtils классом TDoubleEndedQueue, реализующим двухстороннюю очередь элементов (дек). С точки зрения использования, очередь является чем-то средним между динамическим массивом TArrayList и связанным списком TLinkedList. Аналогично связанному списку, добавление и удаление элементов в начале и в конце очереди происходит очень быстро. В то же время, подобно TArrayList, к элементам очереди можно обращаться по числовому индексу. Метод PushFront класса TDoubleEndedQueue помещает значение типа Pointer в начало очереди, метод PushBack – в конец очереди. Соответственно, функция PopFront удаляет из очереди первый элемент и возвращает его как результат, функция PopBack удаляет из очереди последний элемент и возвращает его как результат. Методы RemoveFront и RemoveBack просто удаляют из очереди, соответственно, первый и последний элемент. Метод Swap меняет местами два элемента очереди. Метод Rotate перемещает элемент с указанным индексом и все последующие за ним элементы в начало очереди, а остальные элементы – в конец очереди. RandomShuffle позволяет перемешать все элементы случайным образом. Загрузить элементы очереди из массива указателей можно методом Load класса TDoubleEndedQueue. Наоборот, сохранить все элементы очереди в массиве указателей можно методом Save.  Для вставки одного или нескольких элементов в произвольное место очереди вызывается метод Insert. Для удаления одного или нескольких элементов из произвольного места очереди используется метод RemoveAt. </P>
<P>Двухсторонние очереди отличаются по своей внутренней организации от обычных списков на основе динамических массивов. Они хранятся в виде набора блоков памяти фиксированного размера (по 512 байт). Первый и последний блоки наращиваются в противоположных направлениях. За счет этого двухсторонние очереди экономно используют оперативную память. Кроме того, память возвращается системе при первой возможности. Причем, все это происходит не в ущерб производительности. Деки работают чуть медленнее обычных массивов только из-за необходимости двойной индексации элементов.</P>
<P>В отличие от обычных очередей, при выборке элемента из приоритетной очереди методом Pop возвращается не первый или последний добавленный элемент, а элемент с максимальным значением. Таким образом, последовательность чтения элементов определяется их приоритетами. В модуле AcedContainers приоритетные очереди представлены классом TPriorityQueue. Внутренний массив приоритетной очереди организован в виде кучи. Добавить элемент в очередь TPriorityQueue можно методом Push, прочитать первый, т.е. максимальный элемент, без его удаления методом Peek, удалить произвольный элемент очереди по индексу можно методом RemoveAt, очистить очередь методом Clear. Найти некоторое значение среди элементов приоритетной очереди можно последовательным перебором элементов с помощью методов Search или IndexOf.</P>

<H2>Модуль AcedStorage<A name="IDAT1GGD"></A></H2>
<P>В AcedStorage находятся типы и классы, предназначенные для организации объектного хранилища данных на локальном компьютере или на файловом сервере с возможностью многопользовательского доступа. Хранение данных на файловом сервере широко использовалось до появления серверов баз данных. В настоящее время для хранения информации почти всегда используется какой-либо сервер БД, контролирующий соблюдение ограничений и целостность данных. Несмотря на очевидные достоинства такого подхода, в некоторых случаях имеет смысл пожертвовать этими возможностями в обмен на компактный формат хранения данных, высокую производительность при выборке и изменении данных, отсутствие необходимости установки серверной части приложения, объектно-ориентированное представление данных. Возложение ответственности за целостность данных на клиентское приложение приводит к некоторому усложнению кода. Тем не менее, наличие готового механизма разрешения коллизий на файловом сервере в значительной мере облегчает эту задачу.</P>
<P>При небольшом объеме хранящихся данных довольно эффективным решением может быть загрузка в память приложения целых таблиц и полная перезапись файлов с данными при их модификации. Недостаток такого способа хранения информации, в отличие от реляционных баз данных, заключается в том, что при изменении даже одного элемента коллекции файл данных приходится переписывать целиком. Чтобы уменьшить значимость этой проблемы можно разбивать большие наборы данных на группы элементов, объединенных по какому-либо признаку, и хранить каждую группу в отдельном файле данных. В памяти следует создать ассоциативный массив, связывающий значение признака с соответствующей коллекцией, представляющей часть общего набора данных. При внесении изменений в одну из таких коллекций нет необходимости перезаписывать другие коллекции того же набора данных.</P>
<P>В реляционных базах данных язык SQL можно рассматривать в качестве посредника между потребителем данных (клиентом) и СУБД (сервером). При подготовке и выполнении сложных запросов возникают две проблемы. Во-первых, клиент должен сгенерировать текст запроса в виде предложения на языке SQL. Если структура базы данных включает сложные связи между таблицами, конструирование SQL-запросов представляет собой нетривиальную задачу. Во-вторых, на стороне сервера должен быть произведен разбор полученного SQL-предложения, а затем, с учетом метаданных, оптимизация запроса и выполнение кода для фактической манипуляции данными. Эффективное выполнение SQL-запросов представляет собой научную проблему. С другой стороны, можно изначально отказаться от посредника в виде языка SQL при взаимодействии потребителя с хранилищем данных. Безусловно, такой подход может быть применен только ограниченно, в рамках одного приложения или группы проектов. Однако, при правильной организации структуры данных прямое обращение клиентов к данным хранилища может не только повысить производительность, но и, в конечном счете, уменьшить сложность кода, сократить затраты на разработку и сопровождение приложения, чему способствует, в частности, наличие механизма контроля версий данных.</P>
<P>При использовании модуля AcedStorage все данные представляются в виде объектов: таблицы – в виде экземпляров класса TSerializableCollection, записи в таблицах – экземплярами класса TSerializableObject, точнее производных от него классов. Для сортировки и поиска записей применяются индексы – объекты типа TDataIndex. К библиотеке AcedUtils прилагается демонстрационный проект – приложение, использующее для хранения данных и одновременного доступа к данным нескольких пользователей классы из модуля AcedStorage. Пример кратко описывается далее в этой статье. Рассмотрим эти классы подробнее.</P>
<H4>Класс TSerializableObject</H4>
<P>Абстрактный базовый класс TSerializableObject используется для создания на его основе класса, описывающего записи таблицы данных. Конструктор этого класса является виртуальным. Он может перекрываться в классах-потомках. Каждый экземпляр TSerializableObject содержит идентификатор типа Integer (свойство ID), значение которого уникально в пределах данной коллекции. При загрузке данных объекта из бинарного потока вызывается метод Load, принимающий два параметра: ссылку на экземпляр класса TBinaryReader, из которого нужно прочитать данные, и число, соответствующее сохраненной версии данных. Понятие версии данных введено для того, чтобы была возможность изменять хранимый формат данных в процессе доработки приложения без необходимости создания специального конвертера данных под новый формат. Каждый объект должен уметь загружать в методе Load любую из своих версий до самой последней, включительно. Число, соответствующее последней, т.е. сохраняемой, версии объекта передается в качестве параметра в конструктор коллекции TSerializableCollection. В методе Load при попытке загрузить данные для версии, которая не поддерживается объектом, следует вызвать процедуру RaiseVersionNotSupported из модуля AcedConsts, в которую передаются параметры: Self и числовое значение версии, которая не может быть загружена. Для сохранения данных объекта в бинарном потоке вызывается метод Save класса TSerializableObject, в который передается ссылка на экземпляр класса TBinaryWriter. В методе Save объект должен записать свои данные в бинарный поток. В каждом классе, унаследованном от TSerializableObject, кроме методов Load и Save должны перекрываться методы Equals для проверки равенства двух экземпляров класса и Clone для создания точной копии данного экземпляра класса.</P>
<P>Объекты типа TSerializableObject обычно не создаются сами по себе конcтруктором Create и свойство ID в них не назначается произвольным образом. Все это делается методами коллекции TSerializableCollection, которая полностью управляет временем жизни объектов, загрузкой и сохранением их в бинарном потоке, назначением уникальных идентификаторов, согласованием изменений и прочими аспектами работы с объектами данных.</P>

<H4>Класс TSerializableCollection</H4>
<P>Является центральным элементом концепции объектного хранилища данных. Коллекция содержит набор объектов типа, производного от TSerializableObject, который определяется параметром ItemClassType при вызове конструктора класса TSerializableCollection. Таким образом, все элементы коллекции имеют один и тот же  тип. Полиморфизм здесь не используется, т.к. возможность присутствия в коллекции объектов различного типа приводит к неоправданному усложнению механизмов работы с данными. Внутренний массив элементов, к которому можно обратиться через свойство ItemList, упорядочен по возрастанию значений первичного ключа, т.е. ID. Количество элементов в коллекции возвращается свойством Count. Для ускорения поиска элементы коллекции могут хэшироваться по первичному ключу. Чтобы включить хэширование, надо установить в True значение свойства MaintainHash коллекции. По умолчанию для экономии памяти хэширование отключено. Найти элемент коллекции по значению первичного ключа или просто убедиться в том, что элемент с таким ключом присутствует в коллекции, можно с помощью функции Search. Если нужен не сам объект, а его индекс во внутреннем массиве элементов, следует воспользоваться методом IndexOf. Если в коллекции мало элементов и нужно определить индекс одного из них во внутреннем массиве, можно вызвать метод ScanPointer для линейного поиска указателя. Если элементов много, функция IndexOf быстрее найдет нужный элемент методом бинарного поиска.</P>
<P>Коллекция может быть загружена из бинарного потока типа TBinaryReader методом Load и сохранена в бинарном потоке типа TBinaryWriter методом Save. Метод Equals поэлементно сравнивает данную коллекцию с другой коллекцией и возвращает True, если все соответствующие элементы обеих коллекций равны. Функция Clone возвращает копию коллекции, содержащую копии всех элементов и каждого из индексов. Если предполагается добавить в коллекцию большое число элементов, можно вызвать метод EnsureCapacity для резервирования места во внутренних массивах коллекции. Для полной очистки коллекции используется метод Clear. При вызове этого метода свойство Changed устанавливается в False, т.к. эта операция не предполагает фактического удаления данных на диске. Например, метод Clear вызывается перед загрузкой с диска обновленных данных коллекции. Чтобы по-настоящему удалить из коллекции все элементы, нужно вызвать метод Delete или DeleteDirect для каждого элемента коллекции. Однако, при монопольном доступе к данным и отсутствии необходимости вызова события OnItemDeleted для каждого удаляемого элемента коллекции, можно очистить ее методом Clear, а затем вручную установить свойство Changed в значение True. Это самый быстрый способ удаления всех данных.</P>
<P>Новые элементы коллекции создаются вызовом функции NewItem класса TSerializableCollection. При этом элемент сразу не добавляется в коллекцию. Сначала он должен быть заполнен данными. Затем, для подтверждения изменений вызывается метод EndEdit, который помещает информацию о добавлении новой записи в кэш изменений. Если новая запись не нужна, например, если пользователь нажал кнопку "Отмена" в окне добавления записи, нужно вызвать метод CancelEdit для освобождения памяти, занятой новым элементом. При необходимости корректировки данных нельзя вносить изменения непосредственно в элементы списка ItemList коллекции. Вместо этого, должен быть вызван метод BeginEdit, в который передан идентификатор изменяемого элемента коллекции. Метод BeginEdit возвращает ссылку на копию элемента, в которую можно вносить изменения. Затем эта копия передается в методы EndEdit для подтверждения изменений или CancelEdit для отмены изменений. Удалить элемент коллекции можно вызовом метода Delete с передачей в него идентификатора удаляемого элемента.</P>
<P>Все описанные выше манипуляции с объектами не затрагивают основной список элементов ItemList, т.е. фактический набор данных коллекции. Изменения кэшируются во внутренних массивах: InsertedItemList и DeletedItemList с числом элементов, соответственно, InsertedCount и DeletedCount. В первом из этих массивов находятся элементы, добавленные в коллекцию, а также исправленные, т.е. новые, версии измененных объектов. Во втором массиве находятся удаленные объекты и исходные, т.е. старые, версии измененных объектов. Эти массивы отсортированы в порядке убывания идентификаторов элементов. Проверить наличие кэшированных изменений вообще или изменений для элемента с конкретным идентификатором можно вызовом функции HasChanges. Чтобы применить кэшированные изменения к основному набору элементов используется метод ApplyChanges. Обычно перед вызовом этого метода проверяется наличие обновленных данных на файловом сервере. Если версия файла данных на сервере изменилась, коллекция перечитывается с диска и изменения применяются к новым данным. Управление версиями файлов будет рассмотрено далее в этом разделе. В классе TSerializableCollection предусмотрены специальные события: OnItemInserted, OnItemChanged, OnItemDeleted, которые инициируются, соответственно, при добавлении, изменении и удалении элемента основного набора данных коллекции. Метод ApplyChanges может вернуть одно из следующих значений: appChangesOk (изменения применены успешно), appChangesOriginalObjectChanged (произошла ошибка, связанная с тем, что изменяемый элемент коллекции был одновременно изменен другим пользователем), appChangesUniqueIndexViolation (ошибка, возникающая при попытке вставить значение, нарушающее уникальность одного из индексов коллекции, который не допускает дублирования значений). Чтобы очистить кэш изменений без фактической модификации данных используется метод RejectChanges.</P>
<P>Поясним работу с первичными ключами элементов коллекции. При создании нового элемента методом NewItem свойству ID этого элемента присваивается временное отрицательное значение, которое последовательно уменьшается для каждого следующего создаваемого элемента. При вызове ApplyChanges для добавляемого элемента временное значение ID заменяется настоящим идентификатором, который создается функцией GenerateID коллекции. При изменении идентификатора объекта в коллекции инициируется событие OnItemIDChanged, чтобы можно было обновить внешние ключи в элементах других коллекций, ссылающихся на добавленный элемент. В экземпляре класса TSerializableCollection предполагается, что элементы сохраняют значение свойства ID в виде числа типа Integer. Если заранее известно, что число элементов коллекции не превысит 65535, можно хранить уникальные идентификаторы как 2-байтные значения типа Word. Тогда вместо класса TSerializableCollection надо использовать производный от него класс TWordPrimaryKeyCollection, в котором перекрывается метод GenerateID, чтобы значения первичного ключа не превышали 65535. Если в коллекции может быть не более 255 элементов, имеет смысл хранить ID как один байт. Тогда в качестве коллекции нужно использовать класс TBytePrimaryKeyCollection. Возможна также ситуация, когда вообще нет смысла сохранять уникальный идентификатор вместе с данными объекта. Значение ID может динамически назначаться в момент загрузки коллекции из бинарного потока. Для реализации такой возможности предусмотрен класс TFakePrimaryKeyCollection. При отказе от хранения идентификатора возникает проблема удаления элементов в режиме многопользовательского доступа, т.к. после удаления элемента и повторной загрузки коллекции динамические идентификаторы следующих за ним элементов изменятся. Таким образом, при работе с TFakePrimaryKeyCollection в режиме многопользовательского доступа удаление отдельных элементов коллекции должно быть запрещено.</P>
<P>В классе TSerializableCollection есть еще пара методов для работы с данными в обход кэша изменений. Метод EndEditDirect подтверждает изменение или добавление нового элемента аналогично методу EndEdit, а затем сразу применяет это изменение к основному набору данных, что эквивалентно вызову метода ApplyChanges с идентификатором только что измененного или добавленного объекта. Метод DeleteDirect удаляет элемент с указанным идентификатором из основного набора данных. Методы EndEditDirect и DeleteDirect подходят для работы с данными в режиме монопольного доступа, когда другие пользователи не имеют возможности изменить файл данных одновременно с текущими изменениями.</P>
<P>Каждая коллекция, не являющаяся частью какого-либо объекта, хранится на диске в виде отдельного файла. Для загрузки коллекции из файла предназначен метод LoadFile класса TSerializableCollection, для ее сохранения в файле – метод SaveFileDirect. Второй метод не предназначен для работы с данными в режиме многопользовательского доступа, т.к. он перезаписывает любые изменения, сделанные другими пользователями. При одновременной работе нескольких пользователей для сохранения изменений необходимо открыть файл данных методом OpenFile, затем применить кэшированные изменения к данным методом ApplyChanges. Если изменения применены успешно, можно сохранить коллекцию на диске вызовом метода SaveIfChanged. Если во время применения изменений к данным произошла ошибка, необходимо восстановить исходное состояние набора данных в памяти. Для этого используется метод UndoIfChanged коллекции при открытом файле данных. В конце операции файл данных должен быть закрыт методом CloseFile.</P>
<P>Данные коллекции могут сохраняться на диске в упакованном виде. Для этого в методы OpenFile и SaveFileDirect передается параметр CompressionMode, который, если он отличен от dcmNoCompression, задает режим сжатия записываемого файла данных (одна из констант, перечисленных в описании модуля AcedCompression). Не следует, однако, применять сжатие к файлам, которые содержат часто изменяемые данные, так как это может значительно понизить общую производительность системы, особенно в режиме многопользовательского доступа к данным. В упакованном виде лучше хранить справочники, коды и прочие данные, которые меняются редко. В методы LoadFile, OpenFile и SaveFileDirect передается также параметр EncryptionKey. Он позволяет указать ключ для шифрования файла данных методом RC6. При использовании шифрования, данные, кроме всего прочего, защищаются цифровой сигнатурой SHA-256. Так же как и сжатие, шифрование не стоит использовать для часто изменяемых данных без крайней необходимости.</P>
<P>Несколько пользователей могут одновременно читать данные из одного файла методом LoadFile. Однако, если кто-либо открыл файл методом OpenFile, другие пользователи не могут открыть этот файл для чтения или для записи, пока он не будет закрыт методом CloseFile. При отказе в открытии файла на экране появляется сообщение для пользователя с предложением подождать или повторить попытку открытия файла. Кроме того, пользователь может отменить текущую операцию, в результате чего методы LoadFile, OpenFile и SaveFileDirect вернут значение False. При успешном открытии файла эти методы возвращают True.</P>
<P>В первых четырех байтах файла данных хранится его версия – число, которое изменяется при каждом сохранении данных на диске. Если основной набор данных коллекции не менялся с момента ее загрузки в память или с момента предыдущего сохранения на диске (свойство Changed коллекции равно False), и при вызове метода LoadFile оказывается, что версия файла данных не изменилась за это время, то фактического считывания данных не происходит, так как в этом нет необходимости. То же самое происходит при открытии файла методом OpenFile. Это позволяет уменьшить нагрузку на файловый сервер, сократить объем информации, передаваемой по сети, и в целом повысить производительность приложения.</P>

<H4>Индексы для коллекции</H4>
<P>В коллекции TSerializableCollection элементы упорядочены по возрастанию значения уникального идентификатора элемента. Такой порядок не всегда удобен. Например, конечному пользователю обычно нужен список, отсортированный по именам или по датам и т.п. С этой целью при создании коллекции в конструктор класса TSerializableCollection передается массив, содержащий так называемые индексы – объекты, задающие альтернативный порядок сортировки элементов коллекции. Индексы должны быть созданы заранее, до вызова конструктора коллекции. Все индексы представляются экземплярами классов, производных от TDataIndex. Конкретный класс выбирается в зависимости от типа признака, по которому сортируются данные. Если этот признак – строка (например, наименование объекта), создается индекс типа TStringIndex; если признак – дата, используется класс TDateTimeIndex и т.д. Есть еще специальный класс TCompoundIndex, предназначенный для сортировки элементов коллекции сразу по нескольким признакам.</P>
<P>Индексы предназначены не только для задания порядка элементов коллекции. Основной причиной использования индексов является необходимость быстрого поиска элементов по значению индексируемого признака. Индексы позволяют не только быстро находить отдельные элементы, но также выделять группы элементов, для которых значение признака лежит в определенном интервале. Кроме того, индексы могут быть уникальными, т.е. не допускающими дублирования значения признака. При добавлении и изменении элементов коллекция опрашивает все свои уникальные индексы на предмет того, не вызовет ли каждое конкретное изменение нарушения уникальности какого-либо индекса. Если такая ситуация имеет место, предполагаемые изменения отклоняются.</P>
<P>Изначально все индексы находятся в неактивном состоянии, т.е. не занимают память и не обновляются при каждом изменении коллекции. При попытке воспользоваться индексом, например, для поиска элемента, индекс автоматически активизируется. Его состоянием можно управлять с помощью свойства Active, объявленного в классе TDataIndex. Следует обратить внимание на то, что в часто изменяемых коллекциях лучше постоянно держать все уникальные индексы в активном состоянии. В противном случае, при любом изменении данных выполняется медленный последовательный перебор элементов коллекции индексом для выяснения того, что значение индексируемого признака измененного элемента уникально в пределах набора данных.</P>
<P>Каждый активный индекс содержит полный набор элементов коллекции, отсортированный по значению соответствующего признака. Свойство Descending индекса по умолчанию равно False. Это означает, что элементы сортируются по возрастанию значения признака. Если свойство Descending равно True, элементы сортируются по убыванию значения признака. Для класса TStringIndex, если свойство CaseSensitive равно False, при сортировке и поиске элементов с помощью индекса регистр символов не принимается во внимание. Если это свойство равно True, регистр символов учитывается. К элементам сортированного списка можно обратиться через свойство ItemList индекса, которое возвращает массив указателей на элементы коллекции – экземпляры класса TSerializableObject. Число элементов в этом массиве определяется свойством Count основной коллекции, к которой можно обратиться через свойство Owner индекса. Свойство Unique определяет, является ли данный индекс уникальным. Значение этого свойства передается в конструктор класса индекса и в дальнейшем не может быть изменено. Кроме того, при создании индекса в его конструктор обычно передается адрес функции, которая возвращает значение индексируемого признака для элемента коллекции. В случае класса TCompoundIndex вместо этого передается адрес функции, которая сравнивает между собой два элемента коллекции.</P>
<P>В каждом индексе есть методы для поиска элементов. Метод ScanPointer выполняет линейный поиск указателя во внутреннем массиве индекса. Этим методом стоит пользоваться, только если никакие другие не подходят. Метод Contains возвращает True, если в коллекции присутствует элемент с указанным значением признака. Функция IndexOf находит во внутреннем массиве первый элемент с определенным значением признака и возвращает его индекс в качестве результата, а функция Search в аналогичной ситуации возвращает сам элемент. Во всех индексах, кроме TCompoundIndex, есть функции SelectRange для нахождения диапазона во внутреннем массиве, в котором значение признака больше или равно значению Key1 и меньше значения Key2. При сортировке элементов по убыванию эти функции выделяют диапазон, в котором значение признака меньше или равно значению Key1 и больше значения Key2. Имеется также вариант этой функции, которая возвращает индекс первого элемента массива, для которого индексируемый признак больше или равен (меньше или равен в случае, когда Descending равно True) указанному значению. В классе TStringIndex есть еще метод StartsWith для выделения диапазона во внутреннем массиве, где значение признака для всех элементов начинается с указанной подстроки с учетом или без учета регистра символов в зависимости от значения свойства CaseSensitive.</P>

<H2>Модуль AcedExcelReport<A name="IDAN3GGD"></A></H2>
<P>Модуль предназначен для генерации отчетов с помощью пакета Microsoft Excel. Отчеты создаются на основе XLT-шаблонов или как новые рабочие книги. При построении отчетов, кроме AcedExcelReport, используются модули: Variants, ActiveX, ComObj и, главное, Excel97, содержащий данные библиотеки типов Microsoft Excel. Версии этой библиотеки для Office 2000 и Office XP мало чем отличаются от Excel 97 с точки зрения возможностей, используемых при генерации отчетов. Однако, при подключении к программе модулей Excel2000 и ExcelXP нарушается совместимость со старой версией Microsoft Excel 97. При построении отчетов в Excel через COM-интерфейсы особое внимание следует уделить сокращению числа обращений к серверу, особенно через интерфейс IDispatch. Например, вместо того, чтобы последовательно заполнять данными отдельные ячейки прямоугольной области рабочего листа, гораздо эффективнее создать в памяти вариантный массив, заполнить его, и передать в Excel сразу все значения ячеек прямоугольной области.</P>
<P>Построение отчета обычно начинается с подготовки данных, которые нужно представить в виде таблицы. При этом могут создаваться временные списки типа TArrayList для группирования, сортировки данных и т.п. Затем, когда уже известно количество элементов в каждой области отчета, создаются массивы типа Variant вызовом функции VarArrayCreate из модуля Variants. В эту функцию передаются диапазоны индексов создаваемого массива и тип элементов массива, который может быть равен varVariant, если в массив помещаются данные различного типа. При создании вариантного массива для последующего проецирования его на рабочий лист Microsoft Excel надо учитывать, что первый индекс в этом массиве задает строку, а второй – столбец рабочего листа. После создания массива он заполняется данными, которые нужно показать в отчете. Все значения типа Currency должны быть преобразованы к типу Double функцией G_CurrencyToDouble из модуля AcedCommon перед помещением их в вариантный массив или в ячейку рабочего листа. Для подсчета итоговых сумм лучше использовать функции рабочего листа, а не вычислять эти суммы в процессе группирования данных и не помещать их в отчет в виде готовых чисел.</P>
<P>Следующим этапом после подготовки данных и заполнения вариантных массивов является запуск приложения Microsoft Excel и создание рабочей книги. Для запуска Microsoft Excel вызывается функция StartExcel из модуля AcedExcelReport. Если на компьютере пользователя Microsoft Excel не установлен, на экране появляется соответствующее сообщение для пользователя и функция возвращает False. В случае успеха она возвращает True. Если Excel уже запущен, функция StartExcel ничего не делает, просто возвращает True. Для создания новой рабочей книги вызывается функция CreateExcelWorkbook. В нее как var-параметр передается переменная типа Excel97._Workbook, в которой затем сохраняется ссылка на созданный экземпляр рабочей книги. Один из вариантов функции CreateExcelWorkbook создает пустую рабочую книгу с заданным числом листов. Другой вариант этой функции создает рабочую книгу на основе указанного XLT-шаблона. В случае успеха эта функция возвращает True, а если в процессе создания рабочей книги произошло исключение, оно перехватывается и функция возвращает False. После этого настраивается внешний вид рабочей книги. Это делается вызовом процедуры InitializeExcelWorkbook. При этом можно определить заголовок окна, в котором показывается отчет, а также указать на необходимость или отсутствие необходимости отображения ярлычков листов рабочей книги, нулевых значений на листе, заголовков строк и столбцов (A, B, C…1, 2, 3…), линий сетки, горизонтальной и вертикальной полосы прокрутки рабочего листа.</P>
<P>Получить ссылку на первый лист рабочей книги можно следующим образом: (WB.Worksheets[1] as _Worksheet), где WB – ссылка на рабочую книгу. Диапазон всех ячеек рабочего листа возвращается функцией Get_Cells, вызванной для экземпляра класса _Worksheet. Ссылку на этот диапазон лучше сразу сохранить в отдельной переменной, чтобы впоследствии передавать ее в качестве параметра в различные функций из модуля AcedExcelReport. Следует обратить внимание на то, что по умолчанию нумерация строк и столбцов на рабочем листе начинается с единицы. Если предпочтительно использовать нумерацию с нуля, можно установить в единицу глобальные переменные ExcelRowOffset и ExcelColumnOffset, объявленные в модуле AcedExcelReport. Значения этих переменных прибавляются, соответственно, к номеру строки и номеру столбца при вызове любой функции из AcedExcelReport, в которую передается номер строки и/или номер столбца. Переменные ExcelRowOffset и ExcelColumnOffset позволяют произвольным образом задать начало отсчета на рабочем листе. Например, если таблица данных начинается с ячейки B5, можно присвоить ExcelRowOffset значение 5, а ExcelColumnOffset значение 2 и при обращении к ячейкам таблицы данных использовать индексацию с нуля. Эти переменные обнуляются при вызове процедуры InitializeExcelWorkbook.</P>
<P>Обратиться к запущенному экземпляру приложения Microsoft Excel можно через глобальную переменную ExcelApp, объявленную в модуле AcedExcelReport. Для завершения работы приложения Microsoft Excel и выгрузки его из памяти предназначена процедура ShutdownExcel. Обычно ее не нужно вызывать из прикладной программы, т.к. ShutdownExcel вызывается из раздела finalization модуля AcedExcelReport.</P>
<H4>Классы TExcelRange, TExcelInterval</H4>
<P>Классы TExcelRange и TExcelInterval используются для группирования ячеек рабочего листа. Экземпляр класса TExcelInterval представляет собой прямоугольный диапазон ячеек, экземпляр TExcelRange – коллекцию прямоугольных диапазонов. Когда экземпляр класса TExcelRange проецируется на рабочий лист, вся коллекция диапазонов может быть представлена одним объектом типа Excel97.ExcelRange. Таким образом можно применять различные операции, например, заливку фона ячеек или прорисовку границ, ко всему диапазону сразу, даже если он содержит несмежные ячейки. В модуле AcedExcelReport коллекция интервалов TExcelRange используется, кроме того, для получения текстовой ссылки на диапазон ячеек, которая передается в качестве аргумента для функций рабочего листа, типа "СУММ" или "СЧЁТ".</P>
<P>При создании интервала, т.е. экземпляра класса TExcelInterval, в его конструктор передается номер столбца, строки и, возможно, число строк и столбцов в интервале. Если число строк и столбцов не указано, создается интервал, состоящий из одной ячейки. Кроме того, можно создать интервал, который представляет все ячейки одной или нескольких строк или все ячейки одного или нескольких столбцов рабочего листа. Чтобы спроецировать интервал на рабочий лист, т.е. получить объект типа Excel97.ExcelRange, нужно вызвать функцию GetRange. Для того, чтобы проверить равенство двух интервалов, используется функция Equals. Метод Clone возвращает экземпляр класса, представляющий копию интервала. В классе TExcelInterval имеются свойства, возвращающие номер первой и последней строк интервала, а также номера первого и последнего столбцов.</P>
<P>Экземпляр класса TExcelRange создается в виде пустой коллекции. Но в его конструктор можно передать данные первого интервала, который сразу будет добавлен в коллекцию. Кроме того, коллекция интервалов может быть создана на основе другого экземпляра TExcelRange. В этом случае в нее добавляются копии всех интервалов исходной коллекции. Новые интервалы добавляются в коллекцию методами Add, AddRows, AddColumns. Чтобы полностью очистить коллекцию и освободить память, занимаемую каждым интервалом, используется метод Clear. К отдельным интервалам в составе коллекции можно обратиться через свойство Intervals. Число интервалов возвращается свойством IntervalCount. Метод Equals сравнивает коллекцию с другой коллекцией интервалов. Если две коллекции содержат одни и те же (равные) интервалы, метод возвращает True, если есть какие-либо различия, возвращается False. Метод Clone возвращает копию коллекции, содержащую копии каждого интервала. Для удобства использования интервалы могут быть отсортированы методом EnsureSorted коллекции. Сортировка выполняется по строкам, а затем по столбцам левой верхней ячейки интервала.</P>
<P>Чтобы получить объект типа Excel97.ExcelRange представляющий коллекцию интервалов TExcelRange, надо вызвать функцию GetRange этого класса. Методы GetAbsoluteAddress и GetRelativeAddress класса TExcelRange возвращают текстовую строку, содержащую ссылку на все ячейки коллекции интервалов. Первый метод отличается от второго тем, что он возвращает абсолютную ссылку, т.е., например, строку "R1C1:R2C5;R6:R8". Второй метод возвращает строку, содержащую ссылку относительно указанной ячейки. Например, для той же коллекции интервалов ссылка относительно ячейки R2C5 представляется строкой: "R[-1]C[-4]:RC;R[4]:R[6]".</P>

<H4>Функции для построения отчета</H4>
<P>В модуле AcedExcelReport определены глобальные функции, часто используемые при построении отчетов. Для выполнения других действий можно обращаться к объектам Microsoft Excel через интерфейсы, объявленные в модуле Excel97, сгенерированном из библиотеки типов. В AcedExcelReport есть несколько функций, возвращающих ссылку на диапазон ячеек рабочего листа, т.е. объект типа Excel97.ExcelRange. В частности, функция GetExcelCell возвращает ячейку рабочего листа, находящуюся на пересечении заданной строки и столбца; функция GetExcelRange возвращает прямоугольный диапазон ячеек. Функция GetNamedExcelRange возвращает именованный диапазон ячеек. Функции GetExcelRows и GetExcelColumns возвращают диапазоны, состоящие из всех ячеек определенных строк или столбцов. Чтобы установить значение ячейки или поставить вариантный массив в соответствие ячейкам прямоугольного диапазона, нужно получить ссылку на диапазон функциями GetExcelCell или GetExcelRange, а затем присвоить соответствующее значение свойству Value этого диапазона. То же самое касается, например, изменения шрифта текста с помощью свойства Font диапазона ячеек, задания режима горизонтального/вертикального выравнивания текста с помощью свойств: HorizontalAlignment, VerticalAlignment, задания режима переноса текста свойством WrapText, а также объединения ячеек рабочего листа вызовом метода Merge диапазона ячеек.</P>
<P>Функция InsertExcelRows предназначена для вставки на рабочем листе одной или нескольких строк перед указанной строкой. Функция InserExceltColumns вставляет один или несколько столбцов перед указанным столбцом. Процедуры AssignAbsoluteFormula и AssignRelativeFormula используются для назначения ячейкам рабочего листа формул, реализующих групповые операции, такие как суммирование данных, нахождение максимального значения в диапазоне, подсчет числа непустых ячеек и т.д. При записи формулы адрес обрабатываемого диапазона ячеек указывается в виде абсолютной ссылки (процедурой AssignAbsoluteFormula) или в виде относительной ссылки (процедурой AssignRelativeFormula). Строку, содержащую абсолютную ссылку на прямоугольный диапазон ячеек, можно получить вызовом функции GetAbsoluteAddress. Аналогичную строку, содержащую относительную ссылку на диапазон ячеек, возвращает функция GetRelativeAddress.</P>
<P>Для форматирования границ ячеек вызывается процедура DrawExcelBorders. В нее передается диапазон ячеек в виде объекта Excel97.ExcelRange. Второй параметр (CellBorders) выбирает, какие именно границы ячеек должны отображаться. Здесь передается одна из констант xlcb… или комбинация таких констант. Остальные параметры процедуры DrawExcelBorders задают толщину, стиль и цвет линий. Чтобы, наоборот, удалить прорисовку границ используется процедура ClearExcelBorders. Для применения заливки к диапазону ячеек рабочего листа вызывается процедура FillExcelInterior. Кроме ссылки на диапазон ячеек в нее передается цвет заливки (одна из констант xlColor…), шаблон, накладываемый поверх заливки (одна из констант xlPattern, объявленных в модуле Excel97) и цвет линий шаблона.</P>
<P>После того, как содержимое отчета полностью подготовлено, можно воспользоваться процедурами FreezeExcelRows и FreezeExcelColumns, чтобы облегчить просмотр данных. Эти процедуры задают, соответственно, строки и столбцы, которые не должны перемещаться при прокрутке окна рабочей книги. Иногда бывает удобно выделить шапку таблицы, чтобы она всегда была на экране независимо от длины таблицы. Если предполагается, что пользователь не будет изменять готовый отчет, можно вызвать процедуру ProtectExcelWorksheet для защиты рабочего листа от случайных изменений. Если просматривать отчет удобнее в режиме панорамирования, можно воспользоваться процедурой G_ToggleKey из модуля AcedCommon для включения режима Scroll Lock клавиатуры. После выполнения всех подготовительных действий вызывается процедура ShowExcelWorkbook, в которую передается ссылка на рабочую книгу, полученная ранее при вызове функции CreateExcelWorkbook. Процедура ShowExcelWorkbook отображает рабочую книгу на экране и устанавливает ее свойство Saved в значение True, чтобы при закрытии книги не спрашивалось, нужно ли сохранять изменения.</P>

<H2>Описание демонстрационного проекта<A name="IDAT4GGD"></A></H2>
<P>Кроме исходного кода модулей библиотека AcedUtils включает пример, реализующий полноценное приложение для работы с данными на основе коллекций из модуля AcedStorage. Пример включает несколько отчетов, которые строятся с помощью функций из модуля AcedExcelReport. Рассмотрим подробнее задачу, решаемую этим приложением, и некоторые особенности реализации хранилища данных на основе файлового сервера.</P>
<P>Программа предназначена для учета товаров, поступающих от различных поставщиков. Товары классифицируются по категориям. Основные типы и наборы данных, используемые приложением, описываются в модуле DataTypes, являющемся аналогом модуля данных. Структура базы данных состоит из трех таблиц: поставщики товаров (коллекция Suppliers), категории товаров (коллекция Categories) и сами товары (коллекция Products). Каждая из этих сущностей описывается классом, производным от класса TSerializableObject из модуля AcedStorage. Атрибуты сущностей, т.е. поля таблиц базы данных, представляются свойствами этих классов. Обычно каждому такому свойству соответствует private-поле в классе объекта, используемое для хранения значения этого свойства. Кроме того, в модуле DataTypes имеется класс TPictureObject, предназначенный для сохранения в бинарном потоке и чтения из потока данных объекта типа TPicture. Этот класс используется для хранения изображения, ассоциированного с категорией товаров, которая представляется классом TCategoryObject.</P>
<P>Класс TSupplierObject описывает поставщика товара. Он включает свойства: ID – уникальный идентификатор записи (наследуется от класса TSerializableObject); CompanyName – наименование поставщика; Country – страна поставщика; CityRegion – строка с названием города и, возможно, области; Address – адрес поставщика; PostalCode – почтовый индекс; PhoneFax – номера телефонов и факсов; HttpEmail – адреса электронной почты и web-сайта поставщика; ContactPerson – представитель поставщика, с которым поддерживается контакт; Comments – дополнительная информация о поставщике. Как и во всяком классе, производном от TSerializableObject, в классе TSupplierObject перекрываются методы: Load, Save, Equals, Clone базового класса. В частности, в методе Load выполняется чтение состояния объекта из бинарного потока. Значения всех полей, в том числе FID, унаследованного из TSerializableObject, считываются методами класса TBinaryReader. Метод Save помещает соответствующие данные в бинарный поток, представляемый классом TBinaryWriter. На примере класса TSupplierObject демонстрируется один из приемов оптимального использования пространства в бинарном потоке. Вместо того, чтобы сохранять все подряд значения полей, в методе Save создается переменная Flags, содержащая битовую карту используемых полей, т.е. полей, значения которых отличны от значений по умолчанию. Эта битовая карта помещается в бинарный поток в виде однобайтного значения. Затем в потоке сохраняются значения только тех полей, которые помечены как используемые. В методе Load сначала считывается битовая карта, а затем значения полей, которые помечены в ней единичными битами. В методе Equals класса TSupplierObject выполняется сравнение значений каждого из полей объекта с соответствующими полями другого экземпляра того же класса. Если все поля обоих экземпляров равны, функция возвращает True, в противном случае – False. Метод Clone создает новый экземпляр класса TSupplierObject и копирует в него значения всех полей данного объекта, включая поле FID, унаследованное от класса-предка.</P>
<P>Класс TCategoryObject предназначен для описания категории товара. Он содержит наименование категории (свойство CategoryName), комментарий (свойство Comments) и рисунок, иллюстрирующий данную категорию (свойство Picture). Кроме того, класс TCategoryName включает свойство ID, унаследованное от класса-предка TSerializableObject. Аналогично TSupplierObject, в данном классе перекрываются методы Load, Save, Equals и Clone базового класса. Кроме того, перекрывается виртуальный конструктор Create для создания объекта типа TPictureObject, представляющего рисунок, и метод Destroy для освобождения этого объекта. Следует обратить внимание на то, как в этом классе сохраняется и считывается значение уникального идентификатора записи – поля FID базового класса TSerializableObject. Предполагается, что число возможных категорий товара не превышает 255, поэтому идентификатор записи хранится в виде байта, а не значения типа Integer. При этом сама коллекция категорий товаров представляется экземпляром класса TBytePrimaryKeyCollection.</P>
<P>Класс TProductObject содержит свойства, используемые при описания товара: ID – уникальный идентификатор записи; ProductName – наименование товара; SupplierID – внешний ключ, содержащий ссылку на элемент коллекции Suppliers, представляющий поставщика товара; CategoryID – внешний ключ, содержащий ссылку на элемент коллекции Categories, представляющий категорию товара; QuantityPerUnit – строка, описывающая единицу измерения товара; UnitPrice – цена единицы товара; UnitsInStock – количество товара на складе; UnitsOnOrder – ожидаемое количество товара; Discontinued – признак того, что поставки товара прекращены; Little – признак того, что на складе осталось мало соответствующего товара. На примере класса TProductObject демонстрируется работа с версиями объектов. Предполагается, что в первоначальной версии данного класса отсутствовало свойство Little, оно было добавлено во второй версии. Сохраняемая версия элементов коллекции определяется параметром Version при вызове конструктора класса данной коллекции. Так, при вызове конструктора для коллекции Products во втором параметре передается значение 2. В методе Load класса TProductObject проверяется значение параметра Version. Если версия равна 1, данные сохранены в исходном формате, т.е. без поля FLittle. Если сохраненная версия данных равна 2, в бинарном потоке присутствует значение поля FLittle, которое должно быть прочитано методом ReadBoolean класса TBinaryReader.</P>
<P>Класс TPictureObject, используемый для хранения рисунка, иллюстрирующего категорию товара, может сам по себе найти применение во многих приложениях. Он позволяет сохранять в бинарном потоке растровый рисунок (TBitmap), метафайл (TMetafile) или иконку (TIcon), которые представляются классом TPicture из модуля Graphics. Причем, данные изображения постоянно находятся в упакованном виде и распаковываются только, когда нужно загрузить изображение в объект TPicture. Метод Load класса TPictureObject считывает изображение из объекта TPicture, бинарного потока, представленного классом TBinaryReader, или другого экземпляра класса TPictureObject. Метод Save сохраняет изображение в потоке. Метод Assign загружает рисунок в объект TPicture. Функция Equals возвращает True, если данный экземпляр класса TPictureObject, содержит то же самое изображение, что и экземпляр, переданный в функцию как параметр. Свойства IsBitmap, IsMetafile, IsIcon класса TPictureObject позволяют проверить тип изображения, представленного объектом. Свойство Bytes возвращает указатель на массив байт, содержащий упакованное изображение. Свойство Length – длину этого массива в байтах.</P>
<P>Коллекции Suppliers, Categories, Products создаются процедурой CreateCollections в модуле DataTypes, которая вызывается из раздела инициализации этого модуля. Перед созданием каждой из коллекций создаются индексы, предназначенные для упорядочивания элементов коллекций по какому-либо признаку. Так, поставщики сортируются по значению свойства CompanyName, т.е. по наименованию поставщика, список категорий – по наименованию категории, товары – по наименованию товара, идентификатору поставщика и идентификатору категории. Индексы по наименованиям являются уникальными, что обеспечивает отсутствие в коллекциях элементов с дублирующимися наименованиями. Индексы по внешним ключам в коллекции товаров используются для проверки наличия подчиненных записей в таблице товаров при попытке удаления записи из главной таблицы – коллекции поставщиков или коллекции категорий товаров. Так как количество поставщиков может быть большим, для коллекции Suppliers включается режим хэширования элементов по значению уникального идентификатора (свойство MaintainHash устанавливается в True). Уничтожаются коллекции процедурой FreeCollections, вызываемой из раздела finalization модуля DataTypes.</P>
<P>Для удобства загрузки и сохранения коллекций в модуле DataTypes определены глобальные функции, такие как LoadSuppliers, LoadProducts, SaveSuppliers и т.п., предназначенные для работы с данными в режиме многопользовательского доступа. Функция LoadSuppliers и аналогичные ей функции для загрузки коллекций Categories и Products просто вызывают метод LoadFile соответствующей коллекции и передают в него имя файла данных и, в случае коллекции поставщиков, пароль для дешифрования файла данных. Функции для сохранения изменений в файле реализуют более сложный алгоритм. Рассмотрим его на примере функции SaveSuppliers, используемой для сохранения на диске коллекции поставщиков. В начале функции с помощью свойства HasChanges проверяется наличие в памяти каких-либо кэшированных изменений для коллекции Suppliers. Если изменений нет, то отсутствует необходимость перезаписи файла данных. Если изменения есть, соответствующий файл данных открывается методом OpenFile коллекции. При этом указывается пароль, используемый для шифрования и дешифрования данных коллекции, а также указывается константа dcmFast, включающая режим быстрого сжатия данных для экономии места на диске и сокращения объема информации, пересылаемой по сети. В случае невозможности открытия файла данных (например, если этот файл открыт для записи другим пользователем и его приложение почему-то зависло), кэш изменений очищает и на экран выводится сообщение об ошибке. После того, как файл данных успешно открыт и, при наличии в нем изменений, перечитан с диска, для коллекции Suppliers вызывается метод ApplyChanges. Этот метод применяет кэшированные изменения к набору данных коллекции. Если изменения применены успешно, коллекция сохраняется на диске вызовом метода SaveIfChanged. Если в процессе применения изменений возникли какие-либо проблемы, данные коллекции перечитываются с диска методом UndoIfChanged, а затем на экран выводится сообщение об ошибке. Метод UndoIfChanged перечитывает данные с диска только в случае, если коллекция содержит изменения, т.е. ее свойство Changed равно True. В конце работы файл данных должен быть обязательно закрыт методом CloseFile коллекции. Для большей надежности вызов метода CloseFile помещается в раздел finally блока try-finally структурированной обработки исключений.</P>
<P>Рассмотрим, как выполняется добавление, изменение, удаление записей на примере коллекции поставщиков. Корректировка списка поставщиков производится с помощью формы TSuppliersForm, определенной в модуле SuppliersUnit. При этом используется глобальная переменная SupplierObject типа TSupplierObject, объявленная в модуле DataTypes. Когда пользователь хочет добавить в список нового поставщика и нажимает соответствующую кнопку, вызывается функция NewItem коллекции Suppliers, создающая новый экземпляр класса TSupplierObject, который затем присваивается глобальной переменной SupplierObject. Для ввода данных о новом поставщике на экране отображается форма TSupplierForm из модуля SupplierUnit. Эта форма позволяет пользователю скорректировать значения свойств экземпляра класса TSupplierObject, назначенного переменной SupplierObject. Когда пользователь заполнит все необходимые поля и нажмет кнопку для сохранения изменений, выполняется предварительная проверка введенных данных. Например, проверяется, что наименование поставщика не является пустой строкой и что это наименование не дублируется в списке. Позже, при сохранении данных, это привело бы к ошибке, вызванной нарушением уникальности индекса, и откату всех изменений. Такие ошибки удобнее выявлять на этапе предварительной проверки, чтобы позволить пользователю исправить некорректно введенные данные. Если предварительная проверка прошла успешно, форма ввода данных закрывается, для коллекции Suppliers вызывается метод EndEdit, сохраняющий информацию о добавлении записи в кэше изменений. Затем вызывается рассмотренная выше глобальная функция SaveSuppliers из модуля DataTypes для применения кэшированных изменений к набору данных и сохранения коллекции на диске. Если пользователь отказался от сохранения изменений закрытием по Escape формы ввода данных, вызывается метод CancelEdit коллекции Suppliers для уничтожения объекта, присвоенного переменной SupplierObject. Корректировка записи о поставщике отличается от добавления нового поставщика только тем, что в начале вместо NewItem вызывается функция BeginEdit коллекции поставщиков Suppliers, в которую передается идентификатор редактируемого элемента коллекции.</P>
<P>Когда пользователь удаляет поставщика из коллекции Suppliers, на экране сначала появляется окно для подтверждения удаления записи. Затем открывается файл данных для коллекции товаров Products вызовом метода OpenFile. Используя индекс по внешнему ключу SupplierID коллекции Products, проверяется наличие в списке товаров элемента, ссылающегося на удаляемого поставщика. Если такой товар присутствует в списке, поставщик не может быть удален. Если на этого поставщика никто не ссылается, для коллекции Suppliers вызывается метод Delete, в который передается идентификатор удаляемого элемента. Затем вызывается функция SaveSuppliers для фактического удаления записи из набора данных и сохранения измененной коллекции на диске. Файл данных коллекции Products закрывается только после сохранения всех изменений в коллекции Suppliers. Это нужно, чтобы другой пользователь не мог в момент удаления поставщика добавить товар, который на него ссылается. С этой же целью в момент сохранения коллекции товаров Products вызовом глобальной функции SaveProducts для каждого добавленного или измененного товара проверяется наличие в коллекции Suppliers поставщика, идентификатор которого назначен свойству SupplierID данного товара.</P>
<H2>Заключение<A name="IDAL5GGD"></A></H2>
<P>В статье кратко описана библиотека функций и классов AcedUtils, призванная помочь разработчику на Borland Delphi в создании быстрых и экономичных по используемой памяти и дисковому пространству приложений, работающих на платформе Win32. Более подробную информацию обо всех функциях и классах в составе библиотеки можно почерпнуть из комментариев в исходном коде.</P>
<H6>Версия текста: 1.16</H6>
<P>
<A href="http://acedutils.narod.ru/index.htm">Перейти на главную страницу</A>&nbsp;&nbsp;
<A href="http://acedutils.narod.ru/AcedUtils.zip">Загрузить файл AcedUtils.zip</A>
</P>
</HTML>